[{"categories":["经验记录"],"content":"透明代理的透明即为用户不需要进行任何设置，察觉不到其存在。至于代理是什么，懂得都懂。 ","date":"2021-01-19","objectID":"/posts/d7266c81/:0:0","tags":["Linux","Proxy"],"title":"树莓派+Clash实现透明代理","uri":"/posts/d7266c81/"},{"categories":["经验记录"],"content":"准备 首先你得有个树莓派或者任意一个能装 Linux 系统并且能联网的设备(甚至可以是路由器，不过本文章不适用)，然后你得会配置 Clash 且有一定的 Linux 知识。 本文以树莓派为例子 清单: 树莓派 3B+(RaspberryOS(64 位)) Clash_linux_armv8 可执行文件 ","date":"2021-01-19","objectID":"/posts/d7266c81/:1:0","tags":["Linux","Proxy"],"title":"树莓派+Clash实现透明代理","uri":"/posts/d7266c81/"},{"categories":["经验记录"],"content":"设置 IP 获取方式为静态 因为我是把树莓派作为旁路由，所以会将路由器的 DHCP 的网关设置为树莓派 IP，为了防止树莓派使用自己的 IP 地址作为网关，我们要为树莓派手动指定 IP 及网关。 编辑网络配置文件： sudo nano /etc/network/interfaces auto eth0 iface eth0 inet static address 10.0.0.2 #IP地址 netmask 255.255.0.0 #子掩码 gateway 10.0.0.1 #网关 ","date":"2021-01-19","objectID":"/posts/d7266c81/:2:0","tags":["Linux","Proxy"],"title":"树莓派+Clash实现透明代理","uri":"/posts/d7266c81/"},{"categories":["经验记录"],"content":"解决 53(DNS 监听)端口占用问题 #打开 /etc/systemd/resolved.conf 文件 sudo nano /etc/systemd/resolved.conf #找到DNSStubListener 修改为 DNSStubListener=no DNSStubListener=no 其他软件占用 若系统中安装有 dnsencrypt 或 dnsmasq 等软件，请卸载，此类软件也会占用 53 端口 ","date":"2021-01-19","objectID":"/posts/d7266c81/:3:0","tags":["Linux","Proxy"],"title":"树莓派+Clash实现透明代理","uri":"/posts/d7266c81/"},{"categories":["经验记录"],"content":"开启 Linux 内核转发 #打开/etc/sysctl.conf文件 sudo nano /etc/sysctl.conf #找到net.ipv4.ip_forward将值修改为1 net.ipv4.ip_forward = 1 #立即生效 sudo sysctl -p ","date":"2021-01-19","objectID":"/posts/d7266c81/:4:0","tags":["Linux","Proxy"],"title":"树莓派+Clash实现透明代理","uri":"/posts/d7266c81/"},{"categories":["经验记录"],"content":"安装 clash 将 clash 命名为 clash 且赋予可执行权限，放入/opt目录 编辑/etc/systemd/system/clash.service让 clash 开机自启动 [Unit] Description=clash Documentation=man:clash After=network.target network-online.target nss-lookup.target [Service] Type=simple StandardError=journal User=nobody AmbientCapabilities=CAP_NET_BIND_SERVICE ExecStart=/opt/clash/clash -d /opt/clash ExecReload=/bin/kill -HUP $MAINPID Restart=on-failure RestartSec=1s [Install] WantedBy=multi-user.target #开机自启 sudo systemctl enable clash 安装完之后不急着启动，否则会因为没有配置文件而报错 ","date":"2021-01-19","objectID":"/posts/d7266c81/:5:0","tags":["Linux","Proxy"],"title":"树莓派+Clash实现透明代理","uri":"/posts/d7266c81/"},{"categories":["经验记录"],"content":"配置 clash 编辑/opt/clash/config.yaml redir-port:1811tproxy-port:1812mixed-port:1080allow-lan:truebind-address:\"*\"mode:rulelog-level:warningipv6:falseexternal-controller:0.0.0.0:9090# external-ui: folder# secret: \"\"# interface-name: en0hosts:# '*.clash.dev': 127.0.0.1# '.dev': 127.0.0.1# 'alpha.clash.dev': '::1'dns:enable:truelisten:0.0.0.0:53ipv6:truedefault-nameserver:- 223.5.5.5- 114.114.114.114- 8.8.8.8enhanced-mode:redir-hostuse-hosts:truenameserver:- 114.114.114.114# default value- 8.8.8.8# default value- tls://dns.rubyfish.cn:853# DNS over TLS- https://1.1.1.1/dns-query# DNS over HTTPSfallback:- tcp://1.1.1.1fallback-filter:geoip:trueipcidr:# - 240.0.0.0/4# domain:# - '+.google.com'# - '+.facebook.com'# - '+.youtube.com'proxies:#这里写代理proxy-groups:#这里写代理组proxy-providers:#这里写订阅rules:#这里写规则# 保留地址 =========================================- IP-CIDR,10.0.0.0/8,DIRECT- IP-CIDR,127.0.0.0/8,DIRECT- IP-CIDR,169.254.0.0/16,DIRECT- IP-CIDR,172.16.0.0/12,DIRECT- IP-CIDR,192.168.0.0/16,DIRECT- IP-CIDR,0.0.0.0/8,DIRECT- IP-CIDR,224.0.0.0/4,DIRECT- IP-CIDR,240.0.0.0/4,DIRECT# 最终匹配 =========================================- GEOIP,CN,DIRECT- MATCH,Proxy #重启clash sudo systemctl restart clash.service #查看clash状态 sudo systemctl status clash.service 如果 clash 并未启动(即为状态非active(running))，则可能是配置文件问题 ","date":"2021-01-19","objectID":"/posts/d7266c81/:6:0","tags":["Linux","Proxy"],"title":"树莓派+Clash实现透明代理","uri":"/posts/d7266c81/"},{"categories":["经验记录"],"content":"添加 iptables 规则 添加 iptables 规则，让进入树莓派的流量转发至 clash 如何避免BT流量被代理 若 BT 流量被转发至 clash 可能会导致下载速度变慢，流量不足等问题。下面利用了 BT 流量高端口的特性，仅转发了 1024 以下的端口的流量，若要代理全部流量请去除最后一行--dport 0:1024参数。 sudo iptables -t nat -N clash sudo iptables -t nat -A clash -d 0.0.0.0/8 -j RETURN sudo iptables -t nat -A clash -d 10.0.0.0/8 -j RETURN sudo iptables -t nat -A clash -d 127.0.0.0/8 -j RETURN sudo iptables -t nat -A clash -d 169.254.0.0/16 -j RETURN sudo iptables -t nat -A clash -d 172.16.0.0/12 -j RETURN sudo iptables -t nat -A clash -d 192.168.0.0/16 -j RETURN sudo iptables -t nat -A clash -d 224.0.0.0/4 -j RETURN sudo iptables -t nat -A clash -d 240.0.0.0/4 -j RETURN sudo iptables -t nat -A clash -p tcp -j REDIRECT --to-port 1811 sudo iptables -t nat -A PREROUTING -p tcp --dport 0:1024 -j clash 使用TProxy端口 因为我的 tproxy 端口不知何种原因，并未被打开，所以上面采用的是 REDIRECT 转发，若要使用 Linux 的 tproxy 特性请参考下面的规则: (可用lsof -i:\u003cport\u003e指令查看端口是否开放) sudo ip rule add fwmark 1 table 100 sudo ip route add local default dev lo table 100 sudo iptables -t mangle -N clash sudo iptables -t mangle -A clash -d 0.0.0.0/8 -j RETURN sudo iptables -t mangle -A clash -d 10.0.0.0/8 -j RETURN sudo iptables -t mangle -A clash -d 127.0.0.0/8 -j RETURN sudo iptables -t mangle -A clash -d 169.254.0.0/16 -j RETURN sudo iptables -t mangle -A clash -d 172.16.0.0/12 -j RETURN sudo iptables -t mangle -A clash -d 192.168.0.0/16 -j RETURN sudo iptables -t mangle -A clash -d 224.0.0.0/4 -j RETURN sudo iptables -t mangle -A clash -d 240.0.0.0/4 -j RETURN sudo iptables -t mangle -A clash -p tcp -j TPROXY --on-port 1812 --tproxy-mark 1 sudo iptables -t mangle -A PREROUTING -p tcp --dport 0:1024 -j clash 代理UDP流量 以上规则仅代理了 TCP 流量，若要代理 UDP 流量请追加以下规则 redir sudo iptables -t nat -A clash -p udp -j REDIRECT --to-port 1811 sudo iptables -t nat -A PREROUTING -p udp -j clash tproxy sudo iptables -t mangle -A clash -p udp -j TPROXY --on-port 1812 --tproxy-mark 1 sudo iptables -t mangle -A PREROUTING -p udp -j clash ","date":"2021-01-19","objectID":"/posts/d7266c81/:7:0","tags":["Linux","Proxy"],"title":"树莓派+Clash实现透明代理","uri":"/posts/d7266c81/"},{"categories":["经验记录"],"content":"iptables 规则持久化 安装iptables-persistent sudo apt install iptables-persistent 对当前规则进行保存 sudo netfilter-persistent save ","date":"2021-01-19","objectID":"/posts/d7266c81/:8:0","tags":["Linux","Proxy"],"title":"树莓派+Clash实现透明代理","uri":"/posts/d7266c81/"},{"categories":["经验记录"],"content":"设置路由器DHCP 进入路由器的DHCP设置页面，将网关与DNS服务器改为树莓派的IP地址，然后将手机电脑等设备重新连接路由器即可。 Enjoy youslef! ","date":"2021-01-19","objectID":"/posts/d7266c81/:9:0","tags":["Linux","Proxy"],"title":"树莓派+Clash实现透明代理","uri":"/posts/d7266c81/"},{"categories":["学习日记"],"content":"iptables 是 Linux 系统上常用的命令行工具，主要用来配置防火墙。运用 iptables 我们能够实现流量的转发、拦截等操作 ","date":"2021-01-18","objectID":"/posts/16e870f5/:0:0","tags":["iptables","Linux"],"title":"iptables从入门到放弃","uri":"/posts/16e870f5/"},{"categories":["学习日记"],"content":"iptables 是什么 iptables 是运行在用户空间的应用软件，通过控制 Linux 内核 netfilter 模块，来管理网络数据包的处理和转发。在大部分 Linux 发行版中，可以通过手册页或man iptables获取用户手册。 netfilter是什么(摘自Wiki) Netfilter，在 Linux 内核中的一个软件框架，用于管理网络数据包。不仅具有网络地址转换（NAT）的功能，也具备数据包内容修改、以及数据包过滤等防火墙功能。利用运作于用户空间的应用软件，如 iptables、ebtables 和 arptables 等，来控制 Netfilter，系统管理者可以管理通过 Linux 操作系统的各种网络数据包。1990 年代，Netfilter 在 Linux 2.3.15 版时进入 Linux 内核，正式应用于 Linux 2.4 版。 简而言之就是 Netfilter 的上层程序，用户通过 iptables 指定规则，由 Netfilter 来执行，实现流量的拦截、转发等操作。 ","date":"2021-01-18","objectID":"/posts/16e870f5/:1:0","tags":["iptables","Linux"],"title":"iptables从入门到放弃","uri":"/posts/16e870f5/"},{"categories":["学习日记"],"content":"iptables 的链(chain) iptables 中有 5 个链，分别与 netfilter 中的 hook 对应 PREROUTING - 对应NF_IP_PRE_ROUTING,任何进入网络堆栈的流量都会触发此 hook。 INPUT - 对应NF_IP_LOCAL_IN，如果数据包发送到本地系统，则在路由传入数据包之后，将触发此 hook。 FORWARD - 对应NF_IP_FORWARD，如果该数据包转发到另一台主机，则在路由输入数据包之后将触发此 hook。 OUTPUT - 对应NF_IP_LOCAL_OUT，由本地的出栈流量触发。 POSTROUTING - 对应NF_IP_POST_ROUTING，任何传出的流量都将触发此 hook。 数据包走向: 目的地址为本机的传入流量: -\u003e PREROUTING -\u003e INPUT 目的地址为其他主机的传入流量: -\u003e PREROUTING -\u003e FORWARD -\u003e POSTROUTING -\u003e 本机出站流量: OUTPUT -\u003e POSTROUTING -\u003e ","date":"2021-01-18","objectID":"/posts/16e870f5/:2:0","tags":["iptables","Linux"],"title":"iptables从入门到放弃","uri":"/posts/16e870f5/"},{"categories":["学习日记"],"content":"iptables 的表(tables) ","date":"2021-01-18","objectID":"/posts/16e870f5/:3:0","tags":["iptables","Linux"],"title":"iptables从入门到放弃","uri":"/posts/16e870f5/"},{"categories":["学习日记"],"content":"filter 表 filter 表是默认的表，如果不指明表则使用此表。其通常用于过滤数据包。其中的内建链包括： INPUT,OUTPUT,FORWARD ","date":"2021-01-18","objectID":"/posts/16e870f5/:3:1","tags":["iptables","Linux"],"title":"iptables从入门到放弃","uri":"/posts/16e870f5/"},{"categories":["学习日记"],"content":"nat 表 nat 表如其名，用于地址转换操作。其中的内建链包括： PREROUTING,POSTROUTING,OUTPUT ","date":"2021-01-18","objectID":"/posts/16e870f5/:3:2","tags":["iptables","Linux"],"title":"iptables从入门到放弃","uri":"/posts/16e870f5/"},{"categories":["学习日记"],"content":"mangle 表 mangle 表用于处理数据包。其和 nat 表的主要区别在于，nat 表侧重连接而 mangle 表侧重每一个数据包。其中内建链列表如下。 PREROUTING,OUTPUT,FORWARD,INPUT,POSTROUTING ","date":"2021-01-18","objectID":"/posts/16e870f5/:3:3","tags":["iptables","Linux"],"title":"iptables从入门到放弃","uri":"/posts/16e870f5/"},{"categories":["学习日记"],"content":"raw 表 raw 表用于处理异常，有如下两个内建链： PREROUTING,OUTPUT 流量流向 ","date":"2021-01-18","objectID":"/posts/16e870f5/:3:4","tags":["iptables","Linux"],"title":"iptables从入门到放弃","uri":"/posts/16e870f5/"},{"categories":["学习日记"],"content":"iptables 的规则(rules) 根据规则匹配条件来尝试匹配报文，一旦匹配成功，就由规则定义的处理动作做出处理。 ","date":"2021-01-18","objectID":"/posts/16e870f5/:4:0","tags":["iptables","Linux"],"title":"iptables从入门到放弃","uri":"/posts/16e870f5/"},{"categories":["学习日记"],"content":"匹配条件 基本匹配条件：源地址，目标地址，传输层协议 扩展匹配条件：由扩展模块定义 ","date":"2021-01-18","objectID":"/posts/16e870f5/:4:1","tags":["iptables","Linux"],"title":"iptables从入门到放弃","uri":"/posts/16e870f5/"},{"categories":["学习日记"],"content":"处理动作 基本处理动作：ACCEPT、DROP 扩展处理动作：REJECT、RETURN、LOG、REDIRECT ","date":"2021-01-18","objectID":"/posts/16e870f5/:4:2","tags":["iptables","Linux"],"title":"iptables从入门到放弃","uri":"/posts/16e870f5/"},{"categories":["学习日记"],"content":"iptables的链：内置链和自定义链 内置链：对应于hook functions 自定义链接：用于内置链的扩展和补充，可实现更灵活的规则管理机制；自定义链可以设置完之后，添加到内置链中，方便管理 待续… (iptables的命令操作) ","date":"2021-01-18","objectID":"/posts/16e870f5/:4:3","tags":["iptables","Linux"],"title":"iptables从入门到放弃","uri":"/posts/16e870f5/"},{"categories":["学习日记"],"content":"实现思路 假设现在有个三节点的链表,每个节点具有两个指针: prev —— 上一节点地址 next —— 下一节点地址 ","date":"2021-01-09","objectID":"/posts/53e2617f/:1:0","tags":["C++"],"title":"C语言链表实现","uri":"/posts/53e2617f/"},{"categories":["学习日记"],"content":"插入节点 注:虚线表示删除,D为插入的节点 按照这个图的操作应该是: C-\u003eprev = D D-\u003enext = C D-\u003eprev = B B-\u003enext = D 假设此时的链表传入的table是B,插入的node为D,那么C语言代码为: table-\u003enext-\u003eprev = node node-\u003enext = table-\u003enext node-\u003eprev = table table-\u003enext = node ","date":"2021-01-09","objectID":"/posts/53e2617f/:1:1","tags":["C++"],"title":"C语言链表实现","uri":"/posts/53e2617f/"},{"categories":["学习日记"],"content":"删除节点 注:虚线表示删除,B为要删除的节点 按照这个图的操作应该是: A-\u003enext = C C-\u003eprev = A 假设此时的链表传入的table是B,那么C语言代码为: table-\u003eprev-\u003enext = table-\u003enext; table-\u003enext-\u003eprev = table-\u003eprev; free(table) ","date":"2021-01-09","objectID":"/posts/53e2617f/:1:2","tags":["C++"],"title":"C语言链表实现","uri":"/posts/53e2617f/"},{"categories":["学习日记"],"content":"代码实现 #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e typedef struct node { int id; //节点ID struct node *prev; //上节点地址 struct node *next; //下节点地址 } node; node *createNode(int uid); //创建(节点ID) void addNode(node *table, int uid, int newUid); //增(链表,节点UID,新建节点UID)[在UID节点后插入] void delNode(node *table, int uid); //删(链表,节点UID) void printTable(node *table); //打印(链表) int main() { node *table = createNode(0); addNode(table, 0, 1); addNode(table, 1, 2); addNode(table, 2, 3); addNode(table, 3, 4); addNode(table, 4, 5); addNode(table, 5, 6); delNode(table, 1); delNode(table, 2); delNode(table, 5); printTable(table); exit(0); } node *createNode(int uid) { node *newTable = (node *)malloc(sizeof(node)); newTable-\u003eid = uid; newTable-\u003eprev = NULL; newTable-\u003enext = NULL; return newTable; } void addNode(node *table, int uid, int newUid) { while (1) { if (table == NULL) { //未查找到相应节点 printf(\"Node %d not find!\\n\", uid); return; } if (table-\u003eid == newUid) { //节点ID已存在 printf(\"Node %d exist!\\n\", newUid); return; } if (table-\u003eid == uid) { //查找到相应节点 node *newTable = (node *)malloc(sizeof(node)); if (table-\u003enext != NULL) { //如果存在下一节点 //建立当前与下一链表的联系 newTable-\u003enext = table-\u003enext; table-\u003enext-\u003eprev = newTable; } //建立当前与上一链表的联系 table-\u003enext = newTable; newTable-\u003eprev = table; //写入当前链表ID newTable-\u003eid = newUid; return; } table = table-\u003enext; } } void delNode(node *table, int uid) { while (1) { if (table == NULL) { //未查找到相应节点 printf(\"Node %d not find!\\n\", uid); return; } if (table-\u003eid == uid) { //查找到相应节点 if (table-\u003enext != NULL) { //如果存在下一节点 //建立上一节点与下一节点的连接 table-\u003eprev-\u003enext = table-\u003enext; table-\u003enext-\u003eprev = table-\u003eprev; } else { //如果不存在下一节点 //设置上一节点的next为NULL table-\u003eprev-\u003enext = NULL; } //释放当前节点 free(table); return; } table = table-\u003enext; } } void printTable(node *table) { while (table != NULL) { printf(\"Node: %d\\n\", table-\u003eid); table = table-\u003enext; } return; } ","date":"2021-01-09","objectID":"/posts/53e2617f/:2:0","tags":["C++"],"title":"C语言链表实现","uri":"/posts/53e2617f/"},{"categories":["学习日记"],"content":"curl是从服务器传输数据或向服务器传输数据的工具，熟悉其用法后，完全可以取代 Postman 这一类的图形界面工具。 ","date":"2020-11-07","objectID":"/posts/9058bdc8/:0:0","tags":["curl","Linux"],"title":"使用curl测试API","uri":"/posts/9058bdc8/"},{"categories":["学习日记"],"content":"常规用法 模拟浏览器向网站发送请求curl \u003cURL\u003e,比如 curl \"https://www.bilibili.com\" ","date":"2020-11-07","objectID":"/posts/9058bdc8/:1:0","tags":["curl","Linux"],"title":"使用curl测试API","uri":"/posts/9058bdc8/"},{"categories":["学习日记"],"content":"参数解释 ","date":"2020-11-07","objectID":"/posts/9058bdc8/:2:0","tags":["curl","Linux"],"title":"使用curl测试API","uri":"/posts/9058bdc8/"},{"categories":["学习日记"],"content":"-X 指定请求方法 指定 HTTP 请求的方法。RESTful API的四种方法: curl -X GET \"https://example.com\" curl -X POST \"https://example.com\" curl -X PUT \"https://example.com\" curl -X DELETE \"https://example.com\" ","date":"2020-11-07","objectID":"/posts/9058bdc8/:2:1","tags":["curl","Linux"],"title":"使用curl测试API","uri":"/posts/9058bdc8/"},{"categories":["学习日记"],"content":"-A 指定UA 指定UA（User-Agent）。curl 的默认用户代理字符串是（curl/[version]）。 curl -A 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36' https://google.com 也可以通过-H参数直接指定 curl -H 'User-Agent: php/1.0' https://google.com ","date":"2020-11-07","objectID":"/posts/9058bdc8/:2:2","tags":["curl","Linux"],"title":"使用curl测试API","uri":"/posts/9058bdc8/"},{"categories":["学习日记"],"content":"-b 发送Cookies 向服务器发送 Cookies。 curl -b 'foo1=bar;foo2=bar2' https://google.com 或者发送本地文件中的Cookies curl -b cookies.txt https://www.google.com ","date":"2020-11-07","objectID":"/posts/9058bdc8/:2:3","tags":["curl","Linux"],"title":"使用curl测试API","uri":"/posts/9058bdc8/"},{"categories":["学习日记"],"content":"-c 保存Cookies 将服务器设置的 Cookies 写入一个文件。 curl -c cookies.txt https://www.google.com ","date":"2020-11-07","objectID":"/posts/9058bdc8/:2:4","tags":["curl","Linux"],"title":"使用curl测试API","uri":"/posts/9058bdc8/"},{"categories":["学习日记"],"content":"-d 发送POST数据体 用于发送 POST 请求的数据体。 curl -d'login=emma＆password=123' -X POST https://google.com/login #或者使用本地文件 curl -d '@data.txt' https://google.com/login 使用-d参数以后，HTTP 请求会自动加上标头Content-Type : application/x-www-form-urlencoded。并且会自动将请求转为 POST 方法，因此可以省略-X POST。 ","date":"2020-11-07","objectID":"/posts/9058bdc8/:2:5","tags":["curl","Linux"],"title":"使用curl测试API","uri":"/posts/9058bdc8/"},{"categories":["学习日记"],"content":"-e 设置Referer 设置 HTTP 的标头Referer，表示请求的来源。 curl -e 'https://google.com?q=example' https://www.example.com 可以通过-H参数直接添加标头Referer，达到同样效果。 curl -H 'Referer: https://google.com?q=example' https://www.example.com ","date":"2020-11-07","objectID":"/posts/9058bdc8/:2:6","tags":["curl","Linux"],"title":"使用curl测试API","uri":"/posts/9058bdc8/"},{"categories":["学习日记"],"content":"-F 上传文件 向服务器上传二进制文件。 curl -F 'file=@photo.png' https://google.com/profile 指定 MIME 类型。 curl -F 'file=@photo.png;type=image/png' https://google.com/profile ","date":"2020-11-07","objectID":"/posts/9058bdc8/:2:7","tags":["curl","Linux"],"title":"使用curl测试API","uri":"/posts/9058bdc8/"},{"categories":["学习日记"],"content":"-H 指定HTTP标头 添加 HTTP 请求的标头。 curl -H 'Accept-Language: en-US' -H 'Secret-Message: xyzzy' https://google.com ","date":"2020-11-07","objectID":"/posts/9058bdc8/:2:8","tags":["curl","Linux"],"title":"使用curl测试API","uri":"/posts/9058bdc8/"},{"categories":["学习日记"],"content":"-i 打印HTTP标头 打印出服务器回应的 HTTP 标头。收到服务器回应后，先输出服务器回应的标头，然后空一行，再输出网页的源码。 curl -i https://www.example.com ","date":"2020-11-07","objectID":"/posts/9058bdc8/:2:9","tags":["curl","Linux"],"title":"使用curl测试API","uri":"/posts/9058bdc8/"},{"categories":["学习日记"],"content":"-k 跳过SSL检测 跳过 SSL 检测。不会检查服务器的 SSL 证书是否正确。 ","date":"2020-11-07","objectID":"/posts/9058bdc8/:2:10","tags":["curl","Linux"],"title":"使用curl测试API","uri":"/posts/9058bdc8/"},{"categories":["学习日记"],"content":"-L 开启重定向 让 HTTP 请求跟随服务器的重定向。curl 默认不跟随重定向。 ","date":"2020-11-07","objectID":"/posts/9058bdc8/:2:11","tags":["curl","Linux"],"title":"使用curl测试API","uri":"/posts/9058bdc8/"},{"categories":["学习日记"],"content":"-o 保存为文件 将服务器的回应保存成文件，等同于wget命令。 curl -o example.html https://www.example.com ","date":"2020-11-07","objectID":"/posts/9058bdc8/:2:12","tags":["curl","Linux"],"title":"使用curl测试API","uri":"/posts/9058bdc8/"},{"categories":["学习日记"],"content":"-u Basic Auth认证 用来设置服务器认证的用户名和密码。 curl -u 'bob:12345' https://google.com/login #或 curl https://bob:12345@google.com/login ","date":"2020-11-07","objectID":"/posts/9058bdc8/:2:13","tags":["curl","Linux"],"title":"使用curl测试API","uri":"/posts/9058bdc8/"},{"categories":["学习日记"],"content":"-x 设置代理 指定 HTTP 请求的代理。 curl -x socks5://user:passwd@proxy.com:8080 https://www.example.com 如果没有指定代理协议，默认为 HTTP。 curl -x user:passwd@proxy.com:8080 https://www.example.com ","date":"2020-11-07","objectID":"/posts/9058bdc8/:2:14","tags":["curl","Linux"],"title":"使用curl测试API","uri":"/posts/9058bdc8/"},{"categories":["学习日记"],"content":"之前用过Hexo写过博客，用过一个插件叫hexo-abbrlink，可以生成文章唯一永久链接(8位16进制的字符串)，Hugo有个slug参数，可以用C++写个小程序生成一串字符并填入来模拟这个功能。 这个实现方式只是通过生成8个0-15的随机数实现的，有概率会出现生成的字符重复的现象(只不过概率特别低)，不过其他方法我也不会啊，只能想到这种实现方式了(我太菜了)，就当作是练习C++的面向对象编程吧。 ","date":"2020-11-05","objectID":"/posts/16ea70f5/:0:0","tags":["C++"],"title":"C++实现生成abbrlink","uri":"/posts/16ea70f5/"},{"categories":["学习日记"],"content":"源代码 引入头文件 #include \u003ciostream\u003e#include \u003ccstdlib\u003e#include \u003cctime\u003eusing namespace std; 声明对象 class Abbrlink { private: int abbr[8]; public: void New() { int seed = (int)time(0); for (int i = 0; i \u003c 8; i++) { int bytes = -1; while ((bytes \u003c 0) || (bytes \u003e 15)) { seed--; srand(seed); bytes = rand() % 16; } abbr[i] = bytes; } } void Print() { for (int i = 0; i \u003c 8; i++) { cout \u003c\u003c hex \u003c\u003c abbr[i]; } cout \u003c\u003c endl; } }; 主函数 int main() { Abbrlink abbr; abbr.New(); abbr.Print(); return 0; } ","date":"2020-11-05","objectID":"/posts/16ea70f5/:1:0","tags":["C++"],"title":"C++实现生成abbrlink","uri":"/posts/16ea70f5/"},{"categories":null,"content":" Arduino入门 计算机引导的进化之路 ","date":"0001-01-01","objectID":"/todo/:0:0","tags":null,"title":"Todo","uri":"/todo/"},{"categories":null,"content":"关于网站 首先，欢迎您来到我的博客，至于我为什么会搭建这个博客，我引用一下主题作者的话: 人最重要的特点是会思考，写博客的初衷是保存思维的电子快照。 当然各种文档工具亦或是简单的文本编辑器也能随时记录点滴， 选择建个人网站无非是想满足技术爱好者的偏执。—— Dillon 因为学业繁忙(其实就是懒)，博客可能长年不更新，所以部分内容可能会过时。 ","date":"0001-01-01","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"关于作者 ▇▇岁，是学生(手动狗头) 💻 技术宅，想要探索关于计算机的一切 🤪 拖延症患者，导致想学的东西一直没有学完 ","date":"0001-01-01","objectID":"/about/:2:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"版权问题 除特殊说明外，本站所有内容均受CC BY-NC-SA 4.0保护。 许可协议条款摘要 署名 — 您必须给出适当的署名，提供指向本许可协议的链接，同时标明是否（对原始作品）作了修改。您可以用任何合理的方式来署名，但是不得以任何方式暗示许可人为您或您的使用背书。 非商业性使用 — 您不得将本作品用于商业目的。 相同方式共享 — 如果您再混合、转换或者基于本作品进行创作，您必须基于与原先许可协议相同的许可协议 分发您贡献的作品。 没有附加限制 — 您不得适用法律术语或者 技术措施 从而限制其他人做许可协议允许的事情。 ","date":"0001-01-01","objectID":"/about/:3:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":" 人最重要的特点是会思考，写博客的初衷是保存思维的电子快照。 当然各种文档工具亦或是简单的文本编辑器也能随时记录点滴， 选择建个人网站无非是想满足技术爱好者的偏执。—— Dillon 旧社会已经过去了，但是人们却开始给自己的大脑裹上小脚。 ","date":"0001-01-01","objectID":"/quot/:0:0","tags":null,"title":"凡人名言","uri":"/quot/"}]