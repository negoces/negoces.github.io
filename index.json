[{"categories":[],"content":"我为什么要使用 Node 来搭建 Hugo 博客 我最开始的博客是使用 Hexo 搭建的，那时候刚用的时候觉得很香。但是用到后来，随者文章数量的增加，Hexo 的生成时间直接变成了分钟级别。后来就看到了 Hugo 便将博客转移到了 Hugo 上面并同时看到了 Vercel 的托管服务，当时就觉得白嫖真香。作为一个懒癌晚期，肯定要整个自动部署，很巧 vercel 提供了 hugo 的自动部署，但是不支持 hugo-extended，导致我的博客并不能通过部署，为了解决这个问题便写了个 Github Actions 让 Github 将博客静态文件构建到 gh-pages，vercel 直接部署 gh-pages 分支的静态文件。这次就使用 Node 来简化一下流程，使 vercel 支持 hugo-extended。 原流程:推送仓库 =\u003e Github Actions 构建 =\u003e 发布到 gh-pages 分支 =\u003e 部署到 vervel现流程:推送仓库 =\u003e vercel 构建并部署 ","date":"2021-06-22","objectID":"/posts/3256da5e/:1:0","tags":[],"title":"使用 Node 搭建一个自动部署博客","uri":"/posts/3256da5e/"},{"categories":[],"content":"使用 Yarn 创建一个 Node 项目 首先得确保你安装了 Node.js 并且安装了 Yarn(你对npm很熟悉的话也不是不能用) 之后，咱找个地方创建咱的博客文件夹 mkdir blog \u0026\u0026 cd blog 之后，使用yarn init创建项目 $ yarn init yarn init v1.22.10 question name (node): blog # 项目名 question version (1.0.0): # 版本，可直接回车 question description: my blog # 项目描述，可留空 question entry point (index.js): question repository url: question author: negoces # 作者 question license (MIT): # 开源协议 question private: success Saved package.json Done in 39.47s. ","date":"2021-06-22","objectID":"/posts/3256da5e/:2:0","tags":[],"title":"使用 Node 搭建一个自动部署博客","uri":"/posts/3256da5e/"},{"categories":[],"content":"在 Node 项目中安装 Hugo 并创建博客站点 安装 hugo (期间需要代理，TUN 模式的那种) yarn add hugo-extended 创建站点(hugo 无法在非空文件夹里面创建站点，所以先建在 tmp 目录再移回来) yarn hugo new site tmp mv tmp/* ./ rm -rf tmp ","date":"2021-06-22","objectID":"/posts/3256da5e/:3:0","tags":[],"title":"使用 Node 搭建一个自动部署博客","uri":"/posts/3256da5e/"},{"categories":[],"content":"初始化 Git 仓库并安装主题 git init git branch -m main # 安装主题(链接已加速) git submodule add https://github.com.cnpmjs.org/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack 删除 hugo 默认的配置和内容，替换成主题的示例配置 rm -rf config.toml rm -rf content/ cp themes/hugo-theme-stack/exampleSite/config.yaml ./ cp -r themes/hugo-theme-stack/exampleSite/content/ ./ 删除rich-content文章，否则在本地测试构建时会有些文件下载不下来，导致构建失败(有代理当我没说) rm -rf content/post/rich-content/ yarn hugo serve ","date":"2021-06-22","objectID":"/posts/3256da5e/:4:0","tags":[],"title":"使用 Node 搭建一个自动部署博客","uri":"/posts/3256da5e/"},{"categories":[],"content":"配置 NPM 脚本并测试构建 编辑package.json并加入\"scripts\"项 { \"name\": \"blog\", \"version\": \"1.0.0\", \"description\": \"my blog\", \"main\": \"index.js\", \"author\": \"negoces\", \"license\": \"MIT\", \"dependencies\": { \"hugo-extended\": \"^0.84.0\" }, \"scripts\": { \"build\": \"hugo -d ./dist\" } } 测试构建 yarn build ","date":"2021-06-22","objectID":"/posts/3256da5e/:5:0","tags":[],"title":"使用 Node 搭建一个自动部署博客","uri":"/posts/3256da5e/"},{"categories":[],"content":"配置 gitignore 并创建提交 编辑 .gitignore /dist/ /resources/_gen/ .vscode/* tags /node_modules/ yarn.lock 创建提交 git add * git add .gitignore git commit -m \"init\" ","date":"2021-06-22","objectID":"/posts/3256da5e/:6:0","tags":[],"title":"使用 Node 搭建一个自动部署博客","uri":"/posts/3256da5e/"},{"categories":[],"content":"推送到 Github 并在 Vercel 部署项目 前往 Github 创建仓库 添加远程地址并推送: git remote add origin \u003c远程地址\u003e git push -u origin main 到 vercel 创建项目 参数 值 FRAMEWORK PRESET Other BUILD COMMAND yarn build OUTPUT DIRECTORY dist ","date":"2021-06-22","objectID":"/posts/3256da5e/:7:0","tags":[],"title":"使用 Node 搭建一个自动部署博客","uri":"/posts/3256da5e/"},{"categories":[],"content":"示例网站 https://testblog-three.vercel.app/ 这主题还蛮好看的，后期可能会将现博客迁移到这个主题上 ","date":"2021-06-22","objectID":"/posts/3256da5e/:8:0","tags":[],"title":"使用 Node 搭建一个自动部署博客","uri":"/posts/3256da5e/"},{"categories":["学习日记"],"content":"警告 此文章的部分内容仅适用于 debian buster arm64 系统，对于其他系统仅做参考，不保证能够正常运行 ","date":"2021-06-06","objectID":"/posts/37b9e15f/:0:0","tags":["RaspberryPi","Seafile"],"title":"树莓派安装Seafile文件服务","uri":"/posts/37b9e15f/"},{"categories":["学习日记"],"content":"安装 MariaDB 数据库 若已使用 Docker 安装过 MariaDB 且可用，可忽略此步骤 安装 MariaDB 并设置自启 sudo apt install mariadb-server mariadb-client -y sudo systemctl enable --now mariadb 用 root 权限进入数据库开启密码登录: USE mysql; /* 进入 mysql 库 */ ALTER USER `root`@`localhost` IDENTIFIED WITH mysql_native_password; /* 使用MySQL原生验证 */ ALTER USER `root`@`localhost` IDENTIFIED BY '$PASSWORD'; /* 设置登录密码为 $PASSWORD */ FLUSH privileges; /* 刷新权限 */ 可使用以下指令测试连接: mysql -u root -p 为什么在其他计算机上无法登入数据库 MariaDB 默认监听 127.0.0.1 即:仅本机可登入数据库,如有需求前往 /etc/mysql/mariadb.conf.d/50-server.cnf 文件修改 bind-address = 0.0.0.0 后重启服务,并登入入数据库通过以下 SQL 语句开启 root 的任意域登录: USE mysql; /* 进入 mysql 库 */ CREATE USER `root`@`%` IDENTIFIED WITH mysql_native_password; /* 使用MySQL原生验证 */ CREATE USER `root`@`%` IDENTIFIED BY '$PASSWORD'; /* 设置登录密码为 $PASSWORD */ FLUSH privileges; /* 刷新权限 */ 若在 CREATE 过程中出现 ERROR 1396 (HY000) 错误，则表明该条目已存在，将 CREATE 替换成 ALTER 执行即可。 ","date":"2021-06-06","objectID":"/posts/37b9e15f/:1:0","tags":["RaspberryPi","Seafile"],"title":"树莓派安装Seafile文件服务","uri":"/posts/37b9e15f/"},{"categories":["学习日记"],"content":"安装 Seafile ","date":"2021-06-06","objectID":"/posts/37b9e15f/:2:0","tags":["RaspberryPi","Seafile"],"title":"树莓派安装Seafile文件服务","uri":"/posts/37b9e15f/"},{"categories":["学习日记"],"content":"安装依赖 sudo apt install python3 python3-setuptools python3-pip libmemcached-dev python3-mysqldb -y pip config set global.index-url https://mirrors.sjtug.sjtu.edu.cn/pypi/web/simple sudo pip config set global.index-url https://mirrors.sjtug.sjtu.edu.cn/pypi/web/simple sudo pip3 install Pillow pylibmc captcha jinja2 sqlalchemy==1.4.3 django-pylibmc django-simple-captcha python3-ldap pymysql ","date":"2021-06-06","objectID":"/posts/37b9e15f/:2:1","tags":["RaspberryPi","Seafile"],"title":"树莓派安装Seafile文件服务","uri":"/posts/37b9e15f/"},{"categories":["学习日记"],"content":"创建 Seafile 用户 非必选，但不进行此操作可能会导致后续的步骤需要改动 对 Seafile 服务进行用户隔离，保障数据安全，防止误操作或其他用户恶意删除。 sudo useradd -MUr seafile ","date":"2021-06-06","objectID":"/posts/37b9e15f/:2:2","tags":["RaspberryPi","Seafile"],"title":"树莓派安装Seafile文件服务","uri":"/posts/37b9e15f/"},{"categories":["学习日记"],"content":"下载 Seafile 关于32位(armhf,armv7)系统用户 32 位系统用户请下载8.0.5-armv7版本: seafile-server-8.0.5-buster-armv7.tar.gz # 从 Github 下载 seafile-8.0.3-arm64 (链接包含加速，国内用户可直接下载) wget https://ghproxy.com/github.com/haiwen/seafile-rpi/releases/download/v8.0.3/seafile-server-8.0.3-buster-arm64v8.tar.gz # 解压 seafile-server-8.0.3-buster-arm64v8.tar.gz tar -xzf seafile-server-8.0.3-buster-arm64v8.tar.gz # 在 /opt 目录创建 seafile 文件夹 sudo mkdir /opt/seafile # 将 seafile-server-8.0.3 移动到 /opt/seafile sudo mv seafile-server-8.0.3 /opt/seafile # 设置 /opt/seafile 属主及权限 sudo chown -R seafile:seafile /opt/seafile/ sudo chmod -R 755 /opt/seafile/ ","date":"2021-06-06","objectID":"/posts/37b9e15f/:2:3","tags":["RaspberryPi","Seafile"],"title":"树莓派安装Seafile文件服务","uri":"/posts/37b9e15f/"},{"categories":["学习日记"],"content":"配置 Seafile 关于执行权限问题 由于树莓派默认用户为 pi 而 seafile 文件属主为 seafile ，我们无法直接执行 seafile 文件里面的设置、启动等脚本，解决方法: 切换用户 使用 su 指令切换当前用户 sudo su seafile 当终端以 seafile@raspberrypi 打头时，则表明切换成功，此时的所有操作均由 seafile 执行。 使用 sudo -u seafile \u003c脚本\u003e 来执行脚本 此时将会使用 seafile 执行这个脚本，而不影响其他指令。 以下步骤将使用第二种方式。 cd /opt/seafile/seafile-server-8.0.3 # 进入 seafile 目录 sudo -u seafile ./setup-seafile-mysql.sh # 运行配置脚本 按照提示进行配置，出现以下信息则表明配置成功。 ----------------------------------------------------------------- Your seafile server configuration has been finished successfully. ----------------------------------------------------------------- run seafile server: ./seafile.sh { start | stop | restart } run seahub server: ./seahub.sh { start \u003cport\u003e | stop | restart \u003cport\u003e } ----------------------------------------------------------------- If you are behind a firewall, remember to allow input/output of these tcp ports: ----------------------------------------------------------------- port of seafile fileserver: 8082 port of seahub: 8000 When problems occur, Refer to https://download.seafile.com/published/seafile-manual/home.md for information. ","date":"2021-06-06","objectID":"/posts/37b9e15f/:2:4","tags":["RaspberryPi","Seafile"],"title":"树莓派安装Seafile文件服务","uri":"/posts/37b9e15f/"},{"categories":["学习日记"],"content":"启动 Seafile sudo -u seafile ./seafile.sh start # 一般seafile都能正常启动，除非有其他程序占用端口 sudo -u seafile ./seahub.sh start # 首次启动需要按照提示配置管理员账户II 若 Seahub 无法启动，请参考关于 seahub 无法启动 ","date":"2021-06-06","objectID":"/posts/37b9e15f/:2:5","tags":["RaspberryPi","Seafile"],"title":"树莓派安装Seafile文件服务","uri":"/posts/37b9e15f/"},{"categories":["学习日记"],"content":"测试 Seahub 打开/opt/seafile/conf/gunicorn.conf.py 修改bind = \"127.0.0.1:8000\"为bind = \"0.0.0.0:8000\" 执行sudo -u seafile ./seahub.sh restart重启 seahub 浏览器打开http://\u003cIP\u003e:8000/查看服务是否正常 若要使用反向代理，将gunicorn.conf.py改回原配置，重启 seahub，继续下列步骤 ","date":"2021-06-06","objectID":"/posts/37b9e15f/:2:6","tags":["RaspberryPi","Seafile"],"title":"树莓派安装Seafile文件服务","uri":"/posts/37b9e15f/"},{"categories":["学习日记"],"content":"设置 Seafile 开机自启 创建并编辑/etc/systemd/system/seafile.service [Unit] Description=Seafile After=network.target mysql.service [Service] Type=oneshot ExecStart=/opt/seafile/seafile-server-latest/seafile.sh start ExecStop=/opt/seafile/seafile-server-latest/seafile.sh stop RemainAfterExit=yes User=seafile Group=seafile [Install] WantedBy=multi-user.target 创建并编辑/etc/systemd/system/seahub.service [Unit] Description=Seafile hub After=network.target seafile.service [Service] ExecStart=/opt/seafile/seafile-server-latest/seahub.sh start ExecStop=/opt/seafile/seafile-server-latest/seahub.sh stop User=seafile Group=seafile Type=oneshot RemainAfterExit=yes [Install] WantedBy=multi-user.target 设置开机自启 sudo systemctl enable seafile sudo systemctl enable seahub ","date":"2021-06-06","objectID":"/posts/37b9e15f/:2:7","tags":["RaspberryPi","Seafile"],"title":"树莓派安装Seafile文件服务","uri":"/posts/37b9e15f/"},{"categories":["学习日记"],"content":"配置 Nginx 反向代理 ","date":"2021-06-06","objectID":"/posts/37b9e15f/:3:0","tags":["RaspberryPi","Seafile"],"title":"树莓派安装Seafile文件服务","uri":"/posts/37b9e15f/"},{"categories":["学习日记"],"content":"安装 Nginx sudo apt install nginx -y sudo systemctl enable --now nginx ","date":"2021-06-06","objectID":"/posts/37b9e15f/:3:1","tags":["RaspberryPi","Seafile"],"title":"树莓派安装Seafile文件服务","uri":"/posts/37b9e15f/"},{"categories":["学习日记"],"content":"准备证书及相关文件 前往自己的域名服务商或 Let’s Encrypt 申请证书 使用下列指令下载 dhparam curl https://ssl-config.mozilla.org/ffdhe2048.txt \u003e ./dhparam sudo mv ./dhparam /var/www/ ","date":"2021-06-06","objectID":"/posts/37b9e15f/:3:2","tags":["RaspberryPi","Seafile"],"title":"树莓派安装Seafile文件服务","uri":"/posts/37b9e15f/"},{"categories":["学习日记"],"content":"配置 Nginx 并重启 修改/etc/nginx/sites-available/default server { listen 80 default_server; listen [::]:80 default_server; location / { return 301 https://$host$request_uri; } } server { listen 443 ssl http2; listen [::]:443 ssl http2; server_name _; # 域名 ssl_certificate /path/to/signed_cert_plus_intermediates; # 证书crt ssl_certificate_key /path/to/private_key; # 证书key ssl_session_timeout 1d; ssl_session_cache shared:MozSSL:10m; ssl_session_tickets off; ssl_dhparam /var/www/dhparam; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES256-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES128-SHA:DHE-RSA-AES128-SHA:AES256-GCM-SHA384:AES128-GCM-SHA256:AES256-SHA256:AES128-SHA256:AES256-SHA:AES128-SHA; ssl_prefer_server_ciphers on; add_header Strict-Transport-Security \"max-age=63072000\" always; proxy_set_header X-Forwarded-For $remote_addr; location / { proxy_pass http://127.0.0.1:8000; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Host $server_name; proxy_read_timeout 1200s; client_max_body_size 0; access_log /var/log/nginx/seahub.access.log; error_log /var/log/nginx/seahub.error.log; } location /seafhttp { rewrite ^/seafhttp(.*)$ $1 break; proxy_pass http://127.0.0.1:8082; client_max_body_size 0; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_connect_timeout 36000s; proxy_read_timeout 36000s; proxy_send_timeout 36000s; send_timeout 36000s; } location /media { root /home/user/haiwen/seafile-server-latest/seahub; # seafile位置 } } 以上配置包含了 TLS(https)设置，请在第11行填入自己的域名，例如: server_name mycloud.com;，在第12、13行填入自己的证书路径。 若不需要启用 https 设置，请直接将第4行至第22行删除。 sudo nginx -t # 检查配置是否有错误 sudo systemctl restart nginx # 重启Nginx 访问域名查看页面是否正常加载 ","date":"2021-06-06","objectID":"/posts/37b9e15f/:3:3","tags":["RaspberryPi","Seafile"],"title":"树莓派安装Seafile文件服务","uri":"/posts/37b9e15f/"},{"categories":["学习日记"],"content":"调整 openssl ciphers 顺序优化 TLS 性能 TLSv1.2 的 ciphers 顺序可以在 Nginx 里面通过ssl_ciphers和ssl_prefer_server_ciphers进行设置，对于 TLSv1.3 Nginx 会从 OpenSSL 读取顺序， 但是！OpenSSL 的默认顺序是TLS_AES_256_GCM_SHA384、TLS_CHACHA20_POLY1305_SHA256、TLS_AES_128_GCM_SHA256，对于普通的服务器来说，这三种协议都能跑到 100M/s 以上，基本没什么区别，但是对于树莓派则不一样，因为树莓派鸡肋的性能且没有 AES 硬件加速，它在使用 AES256-GCM 作为加密方式时只能达到 20M/s 的速度，POLY1305 则可以稳定在 100M/s 以上。所以，我们要设置优先 ciphers 来提传输速度。 # 查看配置文件所在位置 openssl version -a | grep OPENSSLDIR 修改刚刚获得的目录下的openssl.cnf，在随后追加 openssl_conf = default_conf [default_conf] ssl_conf = ssl_sect [ssl_sect] system_default = system_default_sect [system_default_sect] Ciphersuites = TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:TLS_AES_128_GCM_SHA256 CipherString = ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES256-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES128-SHA:DHE-RSA-AES128-SHA:AES256-GCM-SHA384:AES128-GCM-SHA256:AES256-SHA256:AES128-SHA256:AES256-SHA:AES128-SHA 验证 openssl ciphers -s -tls1_3 -v # TLSv1.3 openssl ciphers -s -tls1_2 -v # TLSv1.2 重启 Nginx 生效 ","date":"2021-06-06","objectID":"/posts/37b9e15f/:4:0","tags":["RaspberryPi","Seafile"],"title":"树莓派安装Seafile文件服务","uri":"/posts/37b9e15f/"},{"categories":["学习日记"],"content":"安装 Memcached sudo apt install memcached libmemcached-dev -y sudo systemctl enable --now memcached 修改/opt/seafile/conf/seahub_settings.py文件，追加以下代码: CACHES = { 'default': { 'BACKEND': 'django_pylibmc.memcached.PyLibMCCache', 'LOCATION': '127.0.0.1:11211', }, 'locmem': { 'BACKEND': 'django.core.cache.backends.locmem.LocMemCache', }, } COMPRESS_CACHE_BACKEND = 'locmem' 重启 seahub 生效 ","date":"2021-06-06","objectID":"/posts/37b9e15f/:5:0","tags":["RaspberryPi","Seafile"],"title":"树莓派安装Seafile文件服务","uri":"/posts/37b9e15f/"},{"categories":["学习日记"],"content":"关于 seahub 无法启动的问题 ","date":"2021-06-06","objectID":"/posts/37b9e15f/:6:0","tags":["RaspberryPi","Seafile"],"title":"树莓派安装Seafile文件服务","uri":"/posts/37b9e15f/"},{"categories":["学习日记"],"content":"如何 Debug 修改/opt/seafile/conf/gunicorn.conf.py文件 找到daemon = True，将其改为daemon = False 再次运行./seahub.sh start以查看错误，使用Ctrl+C组合键结束进程 注: 记得 Debug 之后将其改回来 注: 部分错误无法使用 start-fastcgi 来 Debug ","date":"2021-06-06","objectID":"/posts/37b9e15f/:6:1","tags":["RaspberryPi","Seafile"],"title":"树莓派安装Seafile文件服务","uri":"/posts/37b9e15f/"},{"categories":["学习日记"],"content":"错误: NameError: name '_mysql' is not defined 原因: MySQLdb为 Python2 的模块，在 Python3 上无法运行 解决方法: 用pymysql替代MySQLdb 具体操作: 安装 python 模块pymysql，并将以下代码添加入/opt/seafile/seafile-server-latest/seahub/seahub/__init__.py文件 import pymysql pymysql.install_as_MySQLdb() ","date":"2021-06-06","objectID":"/posts/37b9e15f/:6:2","tags":["RaspberryPi","Seafile"],"title":"树莓派安装Seafile文件服务","uri":"/posts/37b9e15f/"},{"categories":["学习日记"],"content":"错误: ModuleNotFoundError: No module named 'Image' 原因: seafile 内预装的 PIL 和 Pillow 有问题 解决方法: 对Pillow进行更新 具体操作: 使用以下指令 pip3 install -U Pillow -t /opt/seafile/seafile-server-latest/seahub/thirdpart # 若下载缓慢请使用镜像加速 pip3 install -U Pillow -t /opt/seafile/seafile-server-latest/seahub/thirdpart -i https://mirrors.sjtug.sjtu.edu.cn/pypi/web/simple ","date":"2021-06-06","objectID":"/posts/37b9e15f/:6:3","tags":["RaspberryPi","Seafile"],"title":"树莓派安装Seafile文件服务","uri":"/posts/37b9e15f/"},{"categories":["学习日记"],"content":"错误: ModuleNotFoundError: No module named 'XXX' 原因: XXX 模块缺失或文件权限问题 解决方法: 使用 pip 安装或参考下一条 ","date":"2021-06-06","objectID":"/posts/37b9e15f/:6:4","tags":["RaspberryPi","Seafile"],"title":"树莓派安装Seafile文件服务","uri":"/posts/37b9e15f/"},{"categories":["学习日记"],"content":"指令未找到及其他问题 原因: seafile 文件权限问题 解决方法: 设置 seafile 文件权限 具体操作: 使用以下指令 sudo chown -R seafile:seafile /opt/seafile/ sudo chmod -R 755 /opt/seafile/ ","date":"2021-06-06","objectID":"/posts/37b9e15f/:6:5","tags":["RaspberryPi","Seafile"],"title":"树莓派安装Seafile文件服务","uri":"/posts/37b9e15f/"},{"categories":["学习日记"],"content":"参考 Issues https://github.com/haiwen/seafile-rpi/issues/80 https://github.com/haiwen/seafile-rpi/issues/65 https://github.com/openssl/openssl/issues/7562 ","date":"2021-06-06","objectID":"/posts/37b9e15f/:7:0","tags":["RaspberryPi","Seafile"],"title":"树莓派安装Seafile文件服务","uri":"/posts/37b9e15f/"},{"categories":["学习日记"],"content":"Kubernetes 是用于自动部署，扩展和管理容器化应用程序的开源系统。 注意 当前处于草稿状态，且目前仅到安装 kubeadm 可以，创建集群暂未测试 文章更新时间轴 2021/03/20 文章创建 ","date":"2021-03-20","objectID":"/posts/baaa9162/:0:0","tags":["Linux","k8s","容器","集群"],"title":"Kubernetes 学习日记(未完成)","uri":"/posts/baaa9162/"},{"categories":["学习日记"],"content":"引言 随着微服务、分布式的流行，容器化也逐渐流行起来，Kubernetes 也逐渐成为了一项技能，我便在课余时间抽时间来学习了一下。 Kubernetes 是一个容器编排工具，学习它肯定需要一个集群，但毕竟是学习，肯定没那么的资源来使用，我便使用虚拟机模拟了一个集群来进行学习。 ","date":"2021-03-20","objectID":"/posts/baaa9162/:1:0","tags":["Linux","k8s","容器","集群"],"title":"Kubernetes 学习日记(未完成)","uri":"/posts/baaa9162/"},{"categories":["学习日记"],"content":"用虚拟机创建集群 考虑到 Kubernetes 的系统要求，我打算用 Fedora Server 作为虚拟机的系统，至于虚拟软件则因人而异了，有的人喜欢用 VM，我使用的是 KVM。 Kubernetes 支持的系统 Ubuntu 16.04+ Debian 9+ CentOS 7+ Red Hat Enterprise Linux (RHEL) 7+ Fedora 25+ HypriotOS v1.0.1+ Flatcar Container Linux （使用 2512.3.0 版本测试通过） 前往 Aliyun 下载Fedora-*.iso文件。 下载完毕后创建虚拟机，因为 k8s 的要求我们分配的虚拟机至少需要 2 核 和 2G RAM。 启动虚拟机，根据提示安装。 安装完毕后使用reboot重启，此时iso文件已经可以移除了。 使用以上步骤创建至少两个虚拟机。 ","date":"2021-03-20","objectID":"/posts/baaa9162/:2:0","tags":["Linux","k8s","容器","集群"],"title":"Kubernetes 学习日记(未完成)","uri":"/posts/baaa9162/"},{"categories":["学习日记"],"content":"安装 kubeadm 及其他组件 ","date":"2021-03-20","objectID":"/posts/baaa9162/:3:0","tags":["Linux","k8s","容器","集群"],"title":"Kubernetes 学习日记(未完成)","uri":"/posts/baaa9162/"},{"categories":["学习日记"],"content":"每个节点上 MAC 地址和 product_uuid 的唯一性 Kubernetes 使用这些值来唯一确定集群中的节点。 如果这些值在每个节点上不唯一，可能会导致安装失败。 你可以使用命令 ip link 或 ifconfig -a 来获取网络接口的 MAC 地址 可以使用 sudo cat /sys/class/dmi/id/product_uuid 命令对 product_uuid 校验 ","date":"2021-03-20","objectID":"/posts/baaa9162/:3:1","tags":["Linux","k8s","容器","集群"],"title":"Kubernetes 学习日记(未完成)","uri":"/posts/baaa9162/"},{"categories":["学习日记"],"content":"允许 iptables 检查桥接流量 sudo modprobe br_netfilter cat \u003c\u003cEOF | sudo tee /etc/modules-load.d/k8s.conf br_netfilter EOF cat \u003c\u003cEOF | sudo tee /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF sudo sysctl --system 放行端口 如果你用的是云服务器请确保以下端口已被放行 控制平面节点: 6443,2379-2380,10250,10251,10252 工作节点: 10250,30000-32767 端口的具体作用请查阅官网 ","date":"2021-03-20","objectID":"/posts/baaa9162/:3:2","tags":["Linux","k8s","容器","集群"],"title":"Kubernetes 学习日记(未完成)","uri":"/posts/baaa9162/"},{"categories":["学习日记"],"content":"设置系统镜像 sudo rm -f /etc/yum.repos.d/* echo '[fedora] name=Fedora $releasever - $basearch failovermethod=priority baseurl=https://mirrors.aliyun.com/fedora/releases/$releasever/Everything/$basearch/os/ metadata_expire=28d gpgcheck=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-fedora-$releasever-$basearch skip_if_unavailable=False' | \\ sudo tee /etc/yum.repos.d/fedora.repo \u003e /dev/null echo '[updates] name=Fedora $releasever - $basearch - Updates failovermethod=priority baseurl=https://mirrors.aliyun.com/fedora/updates/$releasever/Everything/$basearch/ enabled=1 gpgcheck=1 metadata_expire=6h gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-fedora-$releasever-$basearch skip_if_unavailable=False' | \\ sudo tee /etc/yum.repos.d/fedora-updates.repo \u003e /dev/null echo '[fedora-modular] name=Fedora Modular $releasever - $basearch failovermethod=priority baseurl=https://mirrors.aliyun.com/fedora/releases/$releasever/Modular/$basearch/os/ enabled=1 metadata_expire=7d gpgcheck=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-fedora-$releasever-$basearch skip_if_unavailable=False' | \\ sudo tee /etc/yum.repos.d/fedora-modular.repo \u003e /dev/null echo '[updates-modular] name=Fedora Modular $releasever - $basearch - Updates failovermethod=priority baseurl=https://mirrors.aliyun.com/fedora/updates/$releasever/Modular/$basearch/ enabled=1 gpgcheck=1 metadata_expire=6h gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-fedora-$releasever-$basearch skip_if_unavailable=False' | \\ sudo tee /etc/yum.repos.d/fedora-updates-modular.repo \u003e /dev/null 系统更新: sudo dnf update ","date":"2021-03-20","objectID":"/posts/baaa9162/:3:3","tags":["Linux","k8s","容器","集群"],"title":"Kubernetes 学习日记(未完成)","uri":"/posts/baaa9162/"},{"categories":["学习日记"],"content":"安装 Docker 添加 mirrors sudo dnf -y install dnf-plugins-core sudo dnf config-manager --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/fedora/docker-ce.repo 安装 Docker sudo dnf install docker-ce docker-ce-cli containerd.io 赋予账户可直接操作 Docker 的权限 sudo usermod -aG docker $USER newgrp docker 添加 Docker 仓库加速 echo \\ '{ \"exec-opts\": [ \"native.cgroupdriver=systemd\" ], \"log-driver\": \"json-file\", \"log-opts\": { \"max-size\": \"100m\" }, \"storage-driver\": \"overlay2\", \"registry-mirrors\": [ \"https://docker.mirrors.sjtug.sjtu.edu.cn\" ] }' | \\ sudo tee /etc/docker/daemon.json \u003e /dev/null 启动 Docker 并设置自启 sudo systemctl start docker sudo systemctl enable docker ","date":"2021-03-20","objectID":"/posts/baaa9162/:3:4","tags":["Linux","k8s","容器","集群"],"title":"Kubernetes 学习日记(未完成)","uri":"/posts/baaa9162/"},{"categories":["学习日记"],"content":"安装 kubeadm 添加 mirror cat \u003c\u003cEOF | sudo tee /etc/yum.repos.d/kubernetes.repo [kubernetes] name=kubernetes baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64 enabled=1 gpgcheck=1 repo_gpgcheck=1 gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg exclude=kubelet kubeadm kubectl EOF 禁用 SELinux setenforce 0 sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config 安装并启动 sudo dnf install -y kubelet kubeadm kubectl --disableexcludes=kubernetes systemctl enable --now kubelet ","date":"2021-03-20","objectID":"/posts/baaa9162/:3:5","tags":["Linux","k8s","容器","集群"],"title":"Kubernetes 学习日记(未完成)","uri":"/posts/baaa9162/"},{"categories":["学习日记"],"content":"使用 kubeadm 创建集群 关闭防火墙 systemctl stop firewalld systemctl disable firewalld 关闭 swap swapoff -a sed -ri 's/.*swap.*/#\u0026/' /etc/fstab 提前拉取所需镜像(因版本而异)，可用kubeadm config images list查看 将k8s.gcr.io换成registry.aliyuncs.com/google_containers/ 也可修改配置实现加速 kubeadm config print-defaults --api-objects ClusterConfiguration \u003e kubeadm.conf生成配置 修改kubernetesVersion:为当前版本 修改imageRepository:为registry.aliyuncs.com/google_containers docker pull registry.aliyuncs.com/google_containers/kube-apiserver:v1.20.5 docker pull registry.aliyuncs.com/google_containers/kube-controller-manager:v1.20.5 docker pull registry.aliyuncs.com/google_containers/kube-scheduler:v1.20.5 docker pull registry.aliyuncs.com/google_containers/kube-proxy:v1.20.5 docker pull registry.aliyuncs.com/google_containers/pause:3.2 docker pull registry.aliyuncs.com/google_containers/etcd:3.4.13-0 docker pull registry.aliyuncs.com/google_containers/coredns:1.7.0 docker tag registry.aliyuncs.com/google_containers/kube-apiserver:v1.20.5 \\ k8s.gcr.io/kube-apiserver:v1.20.5 docker tag registry.aliyuncs.com/google_containers/kube-controller-manager:v1.20.5 \\ k8s.gcr.io/kube-controller-manager:v1.20.5 docker tag registry.aliyuncs.com/google_containers/kube-scheduler:v1.20.5 \\ k8s.gcr.io/kube-scheduler:v1.20.5 docker tag registry.aliyuncs.com/google_containers/kube-proxy:v1.20.5 \\ k8s.gcr.io/kube-proxy:v1.20.5 docker tag registry.aliyuncs.com/google_containers/pause:3.2 \\ k8s.gcr.io/pause:3.2 docker tag registry.aliyuncs.com/google_containers/etcd:3.4.13-0 \\ k8s.gcr.io/etcd:3.4.13-0 docker tag registry.aliyuncs.com/google_containers/coredns:1.7.0 \\ k8s.gcr.io/coredns:1.7.0 初始化 kubeadm init # 或 kubeadm init --ignore-preflight-errors=Swap ","date":"2021-03-20","objectID":"/posts/baaa9162/:4:0","tags":["Linux","k8s","容器","集群"],"title":"Kubernetes 学习日记(未完成)","uri":"/posts/baaa9162/"},{"categories":["学习日记"],"content":"用树莓派做了一个网络存储，想挂载到系统上，便想到了 SMB 协议，之前用过 Samba 但是性能实属不行，恰巧在 Github 上看到了 cifsd 这个项目，并且支持 RDMA 所以在树莓派上面安装试试，结果发现效果还不错，速度蛮快的。 ","date":"2021-03-17","objectID":"/posts/4ab61985/:0:0","tags":["cifsd","SMB","Linux"],"title":"在Linux上安装cifsd启用SMB共享","uri":"/posts/4ab61985/"},{"categories":["学习日记"],"content":"安装必要的依赖 Github 上只有源码，没有现成的二进制文件，软件仓库里面也没有，所以必须自己编译(其实并不意外，这个程序是作为内核模块运行的，所以才有如此之高的性能)。 sudo apt update sudo apt install linux-headers gcc make git autoconf \\ libtool pkg-config libnl-3-dev libnl-genl-3-dev libglib2.0-dev -y ","date":"2021-03-17","objectID":"/posts/4ab61985/:1:0","tags":["cifsd","SMB","Linux"],"title":"在Linux上安装cifsd启用SMB共享","uri":"/posts/4ab61985/"},{"categories":["学习日记"],"content":"编译安装 cifsd 克隆并进入目录 cd ~ git clone https://github.com.cnpmjs.org/cifsd-team/cifsd.git cd cifsd 编译并安装，如果出现问题。。。我相信你百度能力一直可以。 make # 编译 sudo make install # 安装 ","date":"2021-03-17","objectID":"/posts/4ab61985/:2:0","tags":["cifsd","SMB","Linux"],"title":"在Linux上安装cifsd启用SMB共享","uri":"/posts/4ab61985/"},{"categories":["学习日记"],"content":"编译安装 ksmbd-tools 克隆并进入目录 cd ~ git clone https://github.com.cnpmjs.org/cifsd-team/cifsd-tools.git cd ksmbd-tools 编译并安装，如果出现问题。。。我相信你百度能力一直可以。(悄悄告诉你，其实这一步最容易出错) ./autogen.sh ./configure make sudo make install ","date":"2021-03-17","objectID":"/posts/4ab61985/:3:0","tags":["cifsd","SMB","Linux"],"title":"在Linux上安装cifsd启用SMB共享","uri":"/posts/4ab61985/"},{"categories":["学习日记"],"content":"加载模块并设置开机自动加载 加载模块，并编辑/etc/modules-load.d/ksmbd.conf文件以设置开机自动加载。。。算了，怕你不会，直接运行下面的指令吧 sudo modprobe ksmbd echo 'ksmbd' | sudo tee /etc/modules-load.d/ksmbd.conf \u003e /dev/null 用lsmod | grep ksmbd查看模块是否被加载 ","date":"2021-03-17","objectID":"/posts/4ab61985/:4:0","tags":["cifsd","SMB","Linux"],"title":"在Linux上安装cifsd启用SMB共享","uri":"/posts/4ab61985/"},{"categories":["学习日记"],"content":"创建并编辑配置 先创建配置文件夹 sudo mkdir /etc/ksmbd/ ","date":"2021-03-17","objectID":"/posts/4ab61985/:5:0","tags":["cifsd","SMB","Linux"],"title":"在Linux上安装cifsd启用SMB共享","uri":"/posts/4ab61985/"},{"categories":["学习日记"],"content":"创建用户 # $USER 换成你想用的用户名 sudo ksmbd.adduser -a $USER # 输密码，回车，再输一遍，回车 ","date":"2021-03-17","objectID":"/posts/4ab61985/:5:1","tags":["cifsd","SMB","Linux"],"title":"在Linux上安装cifsd启用SMB共享","uri":"/posts/4ab61985/"},{"categories":["学习日记"],"content":"创建共享 参考文档(Github)对/etc/ksmbd/smb.conf进行配置，下面是一键生成示例配置的指令 echo '[global] tcp port = 445 [share] comment = Share path = /home/share read only = no browseable = yes writeable = yes' | \\ sudo tee /etc/ksmbd/smb.conf \u003e /dev/null 经测试tcp port = 445这一行必须存在且需在[global]键下面，否则服务将无法在网络上监听。 ","date":"2021-03-17","objectID":"/posts/4ab61985/:5:2","tags":["cifsd","SMB","Linux"],"title":"在Linux上安装cifsd启用SMB共享","uri":"/posts/4ab61985/"},{"categories":["学习日记"],"content":"启动测试 使用下面的指令启动服务，并用其他设备连接测试(别和我说你不会连接 SMB)，如果测试成功就可以停止服务进行下一步了。 # 启动 sudo ksmbd.mountd # 停止 sudo ksmbd.control -s ","date":"2021-03-17","objectID":"/posts/4ab61985/:6:0","tags":["cifsd","SMB","Linux"],"title":"在Linux上安装cifsd启用SMB共享","uri":"/posts/4ab61985/"},{"categories":["学习日记"],"content":"创建 sevice 文件实现开机自启 ","date":"2021-03-17","objectID":"/posts/4ab61985/:7:0","tags":["cifsd","SMB","Linux"],"title":"在Linux上安装cifsd启用SMB共享","uri":"/posts/4ab61985/"},{"categories":["学习日记"],"content":"创建 sevice 文件 创建/etc/systemd/system/cifsd.service文件，以下是一键指令 echo '[Unit] Description=CIFSD After=network.target network-online.target nss-lookup.target [Service] Type=oneshot StandardError=journal User=root Group=root ExecStart=/usr/local/sbin/ksmbd.mountd ExecStop=/usr/local/sbin/ksmbd.control -s RemainAfterExit=true Restart=on-failure RestartSec=1s [Install] WantedBy=multi-user.target' | \\ sudo tee /etc/systemd/system/cifsd.service \u003e /dev/null ","date":"2021-03-17","objectID":"/posts/4ab61985/:7:1","tags":["cifsd","SMB","Linux"],"title":"在Linux上安装cifsd启用SMB共享","uri":"/posts/4ab61985/"},{"categories":["学习日记"],"content":"设置开机自启 sudo systemctl daemon-reload sudo systemctl enable --now cifsd # 设置自启并立即启动 sudo systemctl status cifsd # 查看当前进程状态 大功告成，可以存你喜欢的小姐姐了 因为 cifsd 支持 RDMA 可以不经过 CPU 直接传输数据，所以理论上是可以跑满网络带宽的 至于你的带宽有多少你可以使用 iperf3 进行测试 ","date":"2021-03-17","objectID":"/posts/4ab61985/:7:2","tags":["cifsd","SMB","Linux"],"title":"在Linux上安装cifsd启用SMB共享","uri":"/posts/4ab61985/"},{"categories":["Game"],"content":"相信有不少人玩 Minecraft 的时候都想与自己的小伙伴一起玩耍，如过你们恰好在同一局域网，那么可以通过游戏内的对局域网开放与小伙伴联机，但是房主必须一直在线，而且非局域网内的小伙伴也无法一起玩耍。 本文章只介绍了如何搭建一个 Minecraft 服务器，并不能直接让非局域网的用户连接，如果你恰好有公网 IP 只需要在路由器里面做个小小的设置(端口映射、端口转发或者叫虚拟服务器)就可以访问了，如果你没有公网 IP 你可以百度内网穿透寻找解决方案 ","date":"2021-03-10","objectID":"/posts/079848ab/:0:0","tags":["Minecraft","Server"],"title":"从零开始搭建一个我的世界服务器","uri":"/posts/079848ab/"},{"categories":["Game"],"content":"基础知识 ","date":"2021-03-10","objectID":"/posts/079848ab/:1:0","tags":["Minecraft","Server"],"title":"从零开始搭建一个我的世界服务器","uri":"/posts/079848ab/"},{"categories":["Game"],"content":"Java Minecraft 玩家应该都知道这是什么东西，这里也不做过多的解释，想要了解的可以自己去百度、Google 或者Wiki。 我们搭建服务需要一个 Java 运行环境即 JRE(Java Runtime Environment)，不过我建议使用 Server JRE 或者 JDK 以便使用更多的启动参数，比如-server。 ","date":"2021-03-10","objectID":"/posts/079848ab/:1:1","tags":["Minecraft","Server"],"title":"从零开始搭建一个我的世界服务器","uri":"/posts/079848ab/"},{"categories":["Game"],"content":"IP 地址和端口 IP 地址(IP Address)：这是一个网络上的概念，在网络上我们的手机、电脑相当于一个个建筑，网络则是一条条道路，IP 地址则是你的的门牌号，通过 IP 地址可以找到你的手机、电脑在什么地方，从而与你建立连接，发送数据。 端口(Port)：前面说 IP 地址是你的门牌号，那么端口指的就是你家的哪个门，前门、后门或者窗户？与哪个端口连接就相当于从哪个入口进去。Java 版 Minecraft 服务器默认监听(listen)端口: 25565 ","date":"2021-03-10","objectID":"/posts/079848ab/:1:2","tags":["Minecraft","Server"],"title":"从零开始搭建一个我的世界服务器","uri":"/posts/079848ab/"},{"categories":["Game"],"content":"准备工作 ","date":"2021-03-10","objectID":"/posts/079848ab/:2:0","tags":["Minecraft","Server"],"title":"从零开始搭建一个我的世界服务器","uri":"/posts/079848ab/"},{"categories":["Game"],"content":"查看 Java 是否安装 使用java -version指令查看 Java 是否已经正确安装，如果输出类似以下内容则表示 Java 已正确安装 java version \"1.8.0_281\" Java(TM) SE Runtime Environment (build 1.8.0_281-b09) Java HotSpot(TM) 64-Bit Server VM (build 25.281-b09, mixed mode) 若报错则表示你的 Java 未正确安装 关于 Server JRE Server JRE 不需要安装(也可以手动安装)，不需要上述操作，在启动服务器时将java指令换成 Server JRE 内 java 二进制文件的绝对路径(如/opt/serverjre/jre/bin/java或D:\\ServerJRE\\jre\\bin\\java.exe)即可。 ","date":"2021-03-10","objectID":"/posts/079848ab/:2:1","tags":["Minecraft","Server"],"title":"从零开始搭建一个我的世界服务器","uri":"/posts/079848ab/"},{"categories":["Game"],"content":"下载一个服务端 下载一个服务端 Jar 文件，官方、spigot、paper 都行，这里用官方 1.16.5 作为演示，下面是下载地址: https://download.mcbbs.net/v1/objects/1b557e7b033b583cd9f66746b7a9ab1ec1673ced/server.jar 创建一个文件夹，名字任意，这里以mcs-1.16.5为例，位置为~/RAMDisk/mcs-1.16.5，将下载的server.jar丢进这个文件夹。 ","date":"2021-03-10","objectID":"/posts/079848ab/:2:2","tags":["Minecraft","Server"],"title":"从零开始搭建一个我的世界服务器","uri":"/posts/079848ab/"},{"categories":["Game"],"content":"启动并配置 在我们创建的文件夹内打开终端(命令行)，使用以下指令启动服务端 # -Xms2G 是最小分配内存，这里设置的是2GB，理论上越大启动越快 # -Xmx4G 是最大分配内存，这里设置的是4GB，理论上不大于物理内存的80% java -Xms2G -Xmx4G -jar server.jar nogui 你会发现他输出三行文字就退出了 [20:01:55] [main/ERROR]: Failed to load properties from file: server.properties [20:01:55] [main/WARN]: Failed to load eula.txt [20:01:55] [main/INFO]: You need to agree to the EULA in order to run the server. Go to eula.txt for more info. 从字面也能看出我们没有同意用户协议，将文件夹下eula.txt文件里面的eula=false改成eula=true即可。同时，我们发现它还在文件夹里面创建了一个叫server.properties的配置文件，我们就现在对其进行修改。 点击下面的\u003e Code以展开配置文件 #Minecraft server properties #Wed Mar 10 20:01:55 CST 2021 # 出生点保护范围，非op玩家在出生点这个距离的范围内无法建造与破坏 spawn-protection=16 # 设置每个tick花费的最大毫秒数。超过该毫秒数时，服务器看门狗将停止服务器程序并附带上信息：服务器的一个tick花费了60.00秒（最长也应该只有0.05秒）；判定服务器已崩溃，它将被强制关闭。遇到这种情况的时候，它会调用 System.exit(1)。 max-tick-time=60000 # GameSpy4协议的服务器监听端口。用于获取服务器信息。 query.port=25565 # 用于自定义世界的生成，参见 https://minecraft-zh.gamepedia.com/%E8%87%AA%E5%AE%9A%E4%B9%89 generator-settings= # 启用后区块文件以同步模式写入。 sync-chunk-writes=true # 是否强制游戏模式 force-gamemode=false # 是否允许进入下界 allow-nether=true # 在服务器上强制执行白名单 enforce-whitelist=false # 游戏模式(高版本不接受数字参数) survival|creative|adventure|spectator gamemode=survival # 向所有在线OP发送所执行命令的输出。 broadcast-console-to-ops=true # GameSpy4协议的服务器监听开关。用于获取服务器信息。 enable-query=false # 如果不为0，服务器将在玩家的空闲时间达到设置的时间（单位为分钟）时将玩家踢出服务器 player-idle-timeout=0 text-filtering-config= # 游戏难度(高版本不接受数字参数) peaceful|easy|normal|hard difficulty=easy # 向所有在线OP发送通过RCON执行的命令的输出。 broadcast-rcon-to-ops=true # 决定攻击型生物（怪物）是否可以生成。 spawn-monsters=true # OP的权限等级 op-permission-level=4 # pvp开关 pvp=true # 此选项控制实体需要距离玩家有多近才会将数据包发送给客户端。更高的数值意味着实体可以在更远的地方就被渲染，同时也可能提高增加延迟的几率。(单位:% 范围:10-1000) entity-broadcast-range-percentage=100 # 是否允许服务端定期发送统计数据到http://snoop.minecraft.net。 snooper-enabled=true # 决定生成的地图的类型。 FLAT|LEGACY|DEFAULT level-type=default # 使服务器在服务器列表中看起来是“在线”的。 enable-status=true # 如果设为 true，服务器难度的设置会被忽略并且设为 hard（困难），玩家在死后会自动切换至旁观模式。 hardcore=false # 是否启用命令方块。 enable-command-block=false # 默认会允许n-1字节的数据包正常发送, 如果数据包为n字节或更大时会进行压缩。-1：完全禁用数据包压缩 0：压缩全部数据包 network-compression-threshold=256 # 设置服务器同时能容纳的最大玩家数量。 max-players=20 # 世界最大半径值 max-world-size=29999984 # 资源包的SHA-1值，必须为小写十六进制，建议填写它。这还没有用于验证资源包的完整性，但是它提高了资源包缓存的有效性和可靠性。 resource-pack-sha1= # 设定函数的默认权限等级。 function-permission-level=2 # rcon远程控制端口 rcon.port=25575 # 服务器（监听的）端口号。 server-port=25565 # 将服务器与一个特定IP绑定。强烈建议留空该属性值！ server-ip= # 决定是否生成村民。 spawn-npcs=true # 允许玩家在安装添加飞行功能的mod前提下在生存模式下飞行。 allow-flight=false # 世界名称及其文件夹名（你可以把你已生成的世界存档复制过来，然后让这个值与那个文件夹的名字保持一致，服务器就可以载入该存档。） level-name=world # 最大视距(单位：区块)，客户端大于此数值也不会显示更远的区块 view-distance=10 # 可选选项，可输入指向一个资源包的URI。玩家可选择是否使用该资源包。注意若该值含\":\"和\"=\"字符，需要在其前加上反斜线(\\) resource-pack= # 决定动物是否可以生成。 spawn-animals=true # 启用服务器的白名单。 white-list=false # 设置RCON远程访问的密码 rcon.password= # 定义是否能生成结构（例如村庄） generate-structures=true # 是否让服务器对比Minecraft账户数据库验证登录信息。(俗称：正版验证) online-mode=true # 玩家在游戏中能够建造的最大高度。 max-build-height=256 # 为世界定义一个种子。 level-seed= # 如果服务器发送的ISP/AS和Mojang的验证服务器的不一样，玩家将会被踢出。(即：不允许使用VPN或代理) prevent-proxy-connections=false # 是否使用针对Linux平台的数据包收发优化。此选项仅会在Linux平台上生成。 use-native-transport=true enable-jmx-monitoring=false # 玩家客户端的多人游戏服务器列表中显示的服务器信息，显示于名称下方。中文需要用unicode，超过59个字符可能会返回“通讯错误” motd=A Minecraft Server # 设置玩家被踢出服务器前，可以发送的数据包数量。设置为0表示关闭此功能。 rate-limit=0 # rcon远程控制开关 enable-rcon=false 然后保存，记得保存！！！ 再次使用上面的指令启动，出现Done (16.409s)! For help, type \"help\"字样表示启动成功。此时便可以进入服务器了。在终端输入stop后回车可关闭服务器。 关于模组和插件 forge 服务端的启动文件不是server.jar，而是forge-x.xx.x.jar，需要将-jar server.jar改成-jar forge-x.xx.x.jar，否则服务器不会加载模组。(注：这里的 xx 只是版本代称，请以实际版本填写。) 模组一般放在mods文件夹内。只有放入指定文件夹才能被服务器加载。(只有 forge 或 fabric 服务器才能加载模组) 插件一般放在plugins文件夹内。只有放入指定文件夹才能被服务器加载。(只有 spigot、paper 等基于 bukkit 或 sponge 服务器才能使用插件) 关于 server-ip= 此参数为服务端监听地址，绑定的是具有此 IP 的网卡 假定我有两张网卡，名称和 IP 分别为: eth0: 192.168.0.101 eth1: 192.168.1.101 如果我设置 server-ip=192.168.1.101 那么服务端只会接受来自 eth1 网卡的连接，来自 eth0 的连接会被丢弃。 如果我设置 server-ip=127.0.0.1 那么服务端只会接受本地回环(loopback)的连接，即只有本机才能进入游戏，就算是来自局域网的连接也无法进入 设置 server-ip=0.0.0.0 或着留空则会监听所有网卡，会接受来自所有网卡的连接，故强烈建议此参数留空！ ","date":"2021-03-10","objectID":"/posts/079848ab/:3:0","tags":["Minecraft","Server"],"title":"从零开始搭建一个我的世界服务器","uri":"/posts/079848ab/"},{"categories":["学习日记"],"content":"在树莓派上面搭建一个内网 git 服务器，用来存放一些代码及镜像一些常用仓库。顺便搭建个 DroneCI 玩玩。 此文章依据怎么方便怎么来的准则，并未考虑稳定与性能，切勿用作生产环境！ ","date":"2021-03-04","objectID":"/posts/a6cf258f/:0:0","tags":["RaspberryPi","Docker","Gitea"],"title":"树莓派4安装Gitea","uri":"/posts/a6cf258f/"},{"categories":["学习日记"],"content":"安装 MariaDB ","date":"2021-03-04","objectID":"/posts/a6cf258f/:1:0","tags":["RaspberryPi","Docker","Gitea"],"title":"树莓派4安装Gitea","uri":"/posts/a6cf258f/"},{"categories":["学习日记"],"content":"拉取 mariadb 镜像 docker pull mariadb ","date":"2021-03-04","objectID":"/posts/a6cf258f/:1:1","tags":["RaspberryPi","Docker","Gitea"],"title":"树莓派4安装Gitea","uri":"/posts/a6cf258f/"},{"categories":["学习日记"],"content":"部署 mariadb docker run -d \\ --name mariadb \\ -p 3306:3306 \\ -e MYSQL_ROOT_PASSWORD=\u003cpassword\u003e \\ --restart=always \\ mariadb ","date":"2021-03-04","objectID":"/posts/a6cf258f/:1:2","tags":["RaspberryPi","Docker","Gitea"],"title":"树莓派4安装Gitea","uri":"/posts/a6cf258f/"},{"categories":["学习日记"],"content":"安装 phpMyAdmin ","date":"2021-03-04","objectID":"/posts/a6cf258f/:2:0","tags":["RaspberryPi","Docker","Gitea"],"title":"树莓派4安装Gitea","uri":"/posts/a6cf258f/"},{"categories":["学习日记"],"content":"拉取 phpmyadmin 镜像 docker pull phpmyadmin ","date":"2021-03-04","objectID":"/posts/a6cf258f/:2:1","tags":["RaspberryPi","Docker","Gitea"],"title":"树莓派4安装Gitea","uri":"/posts/a6cf258f/"},{"categories":["学习日记"],"content":"部署 phpmyadmin docker run -d \\ --name phpmyadmin \\ -p 3380:80 \\ -e PMA_HOST=\u003c树莓派IP\u003e \\ --restart=always \\ phpmyadmin 注意：\u003c树莓派 IP\u003e不能填写 127.0.0.1，负责无法连接到数据库 ","date":"2021-03-04","objectID":"/posts/a6cf258f/:2:2","tags":["RaspberryPi","Docker","Gitea"],"title":"树莓派4安装Gitea","uri":"/posts/a6cf258f/"},{"categories":["学习日记"],"content":"安装 Gitea ","date":"2021-03-04","objectID":"/posts/a6cf258f/:3:0","tags":["RaspberryPi","Docker","Gitea"],"title":"树莓派4安装Gitea","uri":"/posts/a6cf258f/"},{"categories":["学习日记"],"content":"创建 Gitea 数据库 登录\u003c树莓派IP\u003e:3380创建 gitea 用户并创建同名数据库并赋予权限，注意把密码记着 ","date":"2021-03-04","objectID":"/posts/a6cf258f/:3:1","tags":["RaspberryPi","Docker","Gitea"],"title":"树莓派4安装Gitea","uri":"/posts/a6cf258f/"},{"categories":["学习日记"],"content":"获取 Gitea 下载地址: https://dl.gitea.io/gitea/ ","date":"2021-03-04","objectID":"/posts/a6cf258f/:3:2","tags":["RaspberryPi","Docker","Gitea"],"title":"树莓派4安装Gitea","uri":"/posts/a6cf258f/"},{"categories":["学习日记"],"content":"安装 git sudo apt install git git-lfs -y ","date":"2021-03-04","objectID":"/posts/a6cf258f/:3:3","tags":["RaspberryPi","Docker","Gitea"],"title":"树莓派4安装Gitea","uri":"/posts/a6cf258f/"},{"categories":["学习日记"],"content":"创建文件夹并复制文件 创建文件夹 sudo mkdir /opt/gitea sudo mkdir /opt/gitea/etc sudo mkdir /opt/gitea/home sudo mkdir /opt/gitea/var sudo mkdir /opt/gitea/var/lib 复制文件 sudo mv gitea /opt/gitea 设置权限 sudo chown git:git -R /opt/gitea sudo chmod 775 -R /opt/gitea 最终目录结构 /opt/gitea/ ├── etc ├── gitea ├── home └── var └── lib ","date":"2021-03-04","objectID":"/posts/a6cf258f/:3:4","tags":["RaspberryPi","Docker","Gitea"],"title":"树莓派4安装Gitea","uri":"/posts/a6cf258f/"},{"categories":["学习日记"],"content":"创建 git 用户 sudo useradd -d /opt/gitea/home -s /bin/bash -U git ","date":"2021-03-04","objectID":"/posts/a6cf258f/:3:5","tags":["RaspberryPi","Docker","Gitea"],"title":"树莓派4安装Gitea","uri":"/posts/a6cf258f/"},{"categories":["学习日记"],"content":"创建 service 文件 echo \\ '[Unit] Description=Gitea (Git with a cup of tea) After=syslog.target After=network.target docker.service Requires=docker.service [Service] RestartSec=2s Type=simple User=git Group=git WorkingDirectory=/opt/gitea/var/lib ExecStart=/opt/gitea/gitea web --config /opt/gitea/etc/app.ini Restart=always Environment=USER=git HOME=/opt/gitea/home GITEA_WORK_DIR=/opt/gitea/var/lib CapabilityBoundingSet=CAP_NET_BIND_SERVICE AmbientCapabilities=CAP_NET_BIND_SERVICE [Install] WantedBy=multi-user.target' | \\ sudo tee /etc/systemd/system/gitea.service \u003e /dev/null ","date":"2021-03-04","objectID":"/posts/a6cf258f/:3:6","tags":["RaspberryPi","Docker","Gitea"],"title":"树莓派4安装Gitea","uri":"/posts/a6cf258f/"},{"categories":["学习日记"],"content":"启动 gitea 并设置自启 sudo systemctl start gitea sudo systemctl enable gitea sudo systemctl status gitea 访问\u003cIP\u003e:3000进行 Gitea 初始化设置 ","date":"2021-03-04","objectID":"/posts/a6cf258f/:3:7","tags":["RaspberryPi","Docker","Gitea"],"title":"树莓派4安装Gitea","uri":"/posts/a6cf258f/"},{"categories":["学习日记"],"content":"配置 Gitea 编辑/opt/gitea/etc/app.ini，添加或修改以下内容以解除 release 发布限制 [attachment] ENABLE = true PATH = /opt/gitea/home/attachments ALLOWED_TYPES = \u003c文件格式\u003e MAX_SIZE = \u003c文件最大大小,单位M,不需要加\u003e MAX_FILES = \u003c文件最大数量\u003e 关于文件格式: 查询网址: filext.com OSChina 比如要接受所有文件就填写 ALLOWED_TYPES = octet-stream ","date":"2021-03-04","objectID":"/posts/a6cf258f/:4:0","tags":["RaspberryPi","Docker","Gitea"],"title":"树莓派4安装Gitea","uri":"/posts/a6cf258f/"},{"categories":["学习日记"],"content":"配置 Nginx 反向代理 ","date":"2021-03-04","objectID":"/posts/a6cf258f/:5:0","tags":["RaspberryPi","Docker","Gitea"],"title":"树莓派4安装Gitea","uri":"/posts/a6cf258f/"},{"categories":["学习日记"],"content":"安装 Nginx sudo apt update sudo apt install nginx -y ","date":"2021-03-04","objectID":"/posts/a6cf258f/:5:1","tags":["RaspberryPi","Docker","Gitea"],"title":"树莓派4安装Gitea","uri":"/posts/a6cf258f/"},{"categories":["学习日记"],"content":"修改配置 编辑/etc/nginx/sites-available/default server { listen 80 default_server; listen [::]:80 default_server; return 301 https://$host$request_uri; } server { listen 443 ssl http2; listen [::]:443 ssl http2; server_name \u003c域名\u003e; ssl_certificate \u003c证书路径\u003e; ssl_certificate_key \u003c密钥路径\u003e; ssl_session_timeout 1d; ssl_session_cache shared:MozSSL:10m; ssl_session_tickets off; # curl https://ssl-config.mozilla.org/ffdhe2048.txt \u003e /path/to/dhparam ssl_dhparam /path/to/dhparam; # intermediate configuration ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384; ssl_prefer_server_ciphers off; # HSTS (ngx_http_headers_module is required) (63072000 seconds) add_header Strict-Transport-Security \"max-age=63072000\" always; client_max_body_size 4096M; location / { proxy_pass http://127.0.0.1:3000; } } ","date":"2021-03-04","objectID":"/posts/a6cf258f/:5:2","tags":["RaspberryPi","Docker","Gitea"],"title":"树莓派4安装Gitea","uri":"/posts/a6cf258f/"},{"categories":["学习日记"],"content":"重启 Nginx 检查配置并更新 sudo nginx -t sudo systemctl restart nginx ","date":"2021-03-04","objectID":"/posts/a6cf258f/:5:3","tags":["RaspberryPi","Docker","Gitea"],"title":"树莓派4安装Gitea","uri":"/posts/a6cf258f/"},{"categories":["学习日记"],"content":"安装 DroneCI ","date":"2021-03-04","objectID":"/posts/a6cf258f/:6:0","tags":["RaspberryPi","Docker","Gitea"],"title":"树莓派4安装Gitea","uri":"/posts/a6cf258f/"},{"categories":["学习日记"],"content":"拉取镜像 docker pull drone/drone:1 docker pull drone/drone-runner-docker:1 ","date":"2021-03-04","objectID":"/posts/a6cf258f/:6:1","tags":["RaspberryPi","Docker","Gitea"],"title":"树莓派4安装Gitea","uri":"/posts/a6cf258f/"},{"categories":["学习日记"],"content":"生成 RPC 密钥 openssl rand -hex 16 ","date":"2021-03-04","objectID":"/posts/a6cf258f/:6:2","tags":["RaspberryPi","Docker","Gitea"],"title":"树莓派4安装Gitea","uri":"/posts/a6cf258f/"},{"categories":["学习日记"],"content":"部署 DroneCI docker run \\ --volume=/var/lib/drone:/data \\ --env=DRONE_GITEA_SERVER={{DRONE_GITEA_SERVER}} \\ --env=DRONE_GITEA_CLIENT_ID={{DRONE_GITEA_CLIENT_ID}} \\ --env=DRONE_GITEA_CLIENT_SECRET={{DRONE_GITEA_CLIENT_SECRET}} \\ --env=DRONE_RPC_SECRET={{DRONE_RPC_SECRET}} \\ --env=DRONE_SERVER_HOST={{DRONE_SERVER_HOST}} \\ --env=DRONE_SERVER_PROTO={{DRONE_SERVER_PROTO}} \\ --env=DRONE_USER_CREATE=username:{{ADMIN_USERNAME}},admin:true \\ --publish=80:80 \\ --restart=always \\ --detach=true \\ --name=drone \\ drone/drone:1 docker run -d \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -e DRONE_RPC_PROTO=https \\ -e DRONE_RPC_HOST=drone.company.com \\ -e DRONE_RPC_SECRET=super-duper-secret \\ -e DRONE_RUNNER_CAPACITY=2 \\ -e DRONE_RUNNER_NAME=${HOSTNAME} \\ -e DRONE_UI_USERNAME=admin \\ -e DRONE_UI_PASSWORD=admin \\ -p 3200:3000 \\ --restart always \\ --name runner \\ drone/drone-runner-docker:1 docker logs runner ","date":"2021-03-04","objectID":"/posts/a6cf258f/:6:3","tags":["RaspberryPi","Docker","Gitea"],"title":"树莓派4安装Gitea","uri":"/posts/a6cf258f/"},{"categories":["学习日记"],"content":"配置 Nginx 反代 在/etc/nginx/sites-available/default后面追加 server { listen 443 ssl http2; listen [::]:443 ssl http2; server_name \u003c域名\u003e; ssl_certificate \u003c证书路径\u003e; ssl_certificate_key \u003c密钥路径\u003e; ssl_session_timeout 1d; ssl_session_cache shared:MozSSL:10m; ssl_session_tickets off; # curl https://ssl-config.mozilla.org/ffdhe2048.txt \u003e /path/to/dhparam ssl_dhparam /path/to/dhparam; # intermediate configuration ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384; ssl_prefer_server_ciphers off; # HSTS (ngx_http_headers_module is required) (63072000 seconds) add_header Strict-Transport-Security \"max-age=63072000\" always; client_max_body_size 4096M; location / { proxy_pass http://127.0.0.1:3100; } } 注意 Drone 默认会选择 amd64 架构的 runner，但是我们的树莓派是 arm64 的，会导致构建一直处于Pending状态，所以项目的.drone.yml需要指定平台，比如 ---kind:pipelinetype:dockername:defaultplatform:os:linuxarch:arm64steps:- name:buildimage:golangcommands:- go build ","date":"2021-03-04","objectID":"/posts/a6cf258f/:6:4","tags":["RaspberryPi","Docker","Gitea"],"title":"树莓派4安装Gitea","uri":"/posts/a6cf258f/"},{"categories":["学习日记"],"content":"Docker 大法好！！！ ","date":"2021-03-03","objectID":"/posts/c0b3720d/:0:0","tags":["RaspberryPi","Docker"],"title":"树莓派4安装Docker","uri":"/posts/c0b3720d/"},{"categories":["学习日记"],"content":"安装必要工具 sudo apt update sudo apt install apt-transport-https ca-certificates curl gnupg -y ","date":"2021-03-03","objectID":"/posts/c0b3720d/:1:0","tags":["RaspberryPi","Docker"],"title":"树莓派4安装Docker","uri":"/posts/c0b3720d/"},{"categories":["学习日记"],"content":"安装 Docker 下载安装 GPG 密钥 curl -fsSL https://mirror.sjtu.edu.cn/docker-ce/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 添加镜像源 echo \\ \"deb [arch=arm64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirror.sjtu.edu.cn/docker-ce/linux/debian buster stable\" | \\ sudo tee /etc/apt/sources.list.d/docker.list \u003e /dev/null 安装 Docker-ce sudo apt update sudo apt install docker-ce docker-ce-cli containerd.io -y ","date":"2021-03-03","objectID":"/posts/c0b3720d/:2:0","tags":["RaspberryPi","Docker"],"title":"树莓派4安装Docker","uri":"/posts/c0b3720d/"},{"categories":["学习日记"],"content":"赋予账户可直接操作 Docker 的权限 将自己的账户添加到 docker 组 sudo usermod -aG docker $USER newgrp docker ","date":"2021-03-03","objectID":"/posts/c0b3720d/:3:0","tags":["RaspberryPi","Docker"],"title":"树莓派4安装Docker","uri":"/posts/c0b3720d/"},{"categories":["学习日记"],"content":"添加 Docker 仓库加速 编辑或新建/etc/docker/daemon.json文件，向其中添加registry-mirrors项 echo \\ '{ \"registry-mirrors\": [\"https://docker.mirrors.sjtug.sjtu.edu.cn\"] }' | \\ sudo tee /etc/docker/daemon.json \u003e /dev/null ","date":"2021-03-03","objectID":"/posts/c0b3720d/:4:0","tags":["RaspberryPi","Docker"],"title":"树莓派4安装Docker","uri":"/posts/c0b3720d/"},{"categories":["学习日记"],"content":"启动 Docker 并设置自启 sudo systemctl start docker sudo systemctl enable docker sudo systemctl status docker ","date":"2021-03-03","objectID":"/posts/c0b3720d/:5:0","tags":["RaspberryPi","Docker"],"title":"树莓派4安装Docker","uri":"/posts/c0b3720d/"},{"categories":["学习日记"],"content":"安装 Portainer 面板 为了防止待会部署面板时拉取过慢，我们提前拉取 docker pull portainer/portainer-ce 部署面板 docker volume create portainer_data docker run -d \\ -p 8000:8000 \\ -p 9000:9000 \\ --name=portainer \\ --restart=always \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v portainer_data:/data \\ portainer/portainer-ce 到此为止，Docker 和 Portainer 面板均已部署完毕，可前往\u003cip\u003e：9000访问面板 ","date":"2021-03-03","objectID":"/posts/c0b3720d/:6:0","tags":["RaspberryPi","Docker"],"title":"树莓派4安装Docker","uri":"/posts/c0b3720d/"},{"categories":["学习日记"],"content":"将树莓派作为二级路由器 AP模式 与 路由模式 树莓派可作为纯 AP 1 使用，这里启用了 NAT 作为二级路由使用。 AP： 全称 WirelessAccessPoint(无线访问接入点) 是无线网和有线网之间沟通的桥梁 ↩︎ 测试环境: 设备: RaspberryPi 3B+ 系统: Raspberry Pi OS (与 Raspbian 类似是官方的 64 位系统。) 上级路由: 10.0.0.1 (OpenWRT) ","date":"2021-03-03","objectID":"/posts/542347b3/:0:0","tags":["RaspberryPi","iptables","hostapd","dnsmasq"],"title":"把树莓派当作热点","uri":"/posts/542347b3/"},{"categories":["学习日记"],"content":"安装系统 系统安装及设置语言等操作请参考此文章 注意 树莓派 3 与树莓派 4 的入门安装基本一致，区别在于树莓派 3 的 USB 启动不需要更新 eeprom ","date":"2021-03-03","objectID":"/posts/542347b3/:1:0","tags":["RaspberryPi","iptables","hostapd","dnsmasq"],"title":"把树莓派当作热点","uri":"/posts/542347b3/"},{"categories":["学习日记"],"content":"安装必要软件 完全更新系统，防止安装软件时出现依赖不兼容等问题。 sudo apt update sudo apt full-upgrade -y 安装hostapd、dnsmasq等软件，其中hostapd可以将你的树莓派变成热点向外发出无线信号，dnsmasq作为 DHCP 服务器与 DNS 缓存，为连接的设备分配 IP 地址及提供 DNS 服务。 sudo apt install hostapd dnsmasq netfilter-persistent iptables-persistent -y ","date":"2021-03-03","objectID":"/posts/542347b3/:2:0","tags":["RaspberryPi","iptables","hostapd","dnsmasq"],"title":"把树莓派当作热点","uri":"/posts/542347b3/"},{"categories":["学习日记"],"content":"设置无线接口 编辑/etc/dhcpcd.conf添加下面配置(仅树莓派是修改此文件，debian 需修改/etc/network/interfaces文件)，为 wlan0 接口绑定 IP 地址，用于后面的hostapd绑定接口。 ip_address=后的 IP 地址可以填写任意子网 IP，但不要和你的上级路由重复，比如一般家用路由器为 192.168.1.1/24 客户端可用的 IP 为 192.168.1.2 - 192.168.1.254 (192.168.1.1 为路由器自身地址，192.168.1.255 为广播地址) 子网范围 A 类: 10.0.0.0 - 10.255.255.255 (子网掩码: 255.0.0.0) B 类: 172.16.0.0 - 172.31.255.255 (子网掩码: 255.240.0.0) C 类: 192.168.0.0 - 192.168.255.255 (子网掩码: 255.255.0.0) interface wlan0 static ip_address=172.24.0.1/24 nohook wpa_supplicant ","date":"2021-03-03","objectID":"/posts/542347b3/:3:0","tags":["RaspberryPi","iptables","hostapd","dnsmasq"],"title":"把树莓派当作热点","uri":"/posts/542347b3/"},{"categories":["学习日记"],"content":"开启内核转发 启用 Linux 内核转发功能，使得进入树莓派的流量能顺利的通过树莓派转发出去，否则之后将会出现可以连上树莓派但是无法联网的情况。 echo \"net.ipv4.ip_forward=1\" | \\ sudo tee /etc/sysctl.d/routed-ap.conf \u003e /dev/null ","date":"2021-03-03","objectID":"/posts/542347b3/:4:0","tags":["RaspberryPi","iptables","hostapd","dnsmasq"],"title":"把树莓派当作热点","uri":"/posts/542347b3/"},{"categories":["学习日记"],"content":"配置无线国家代码 使用raspi-config工具设置 WLAN 国家代码 sudo raspi-config 依次选择Localisation Options -\u003e WLAN Country -\u003e AU，为什么不用 CN？不知道是不是树莓派的问题，CN 的 5G 频段少之又少，而且都不支持 80MHz，所以选择了 AU。设置完成后返回主菜单，Finished，Reboot ","date":"2021-03-03","objectID":"/posts/542347b3/:5:0","tags":["RaspberryPi","iptables","hostapd","dnsmasq"],"title":"把树莓派当作热点","uri":"/posts/542347b3/"},{"categories":["学习日记"],"content":"配置并启用 hostapd 先确保无线模块未被禁用 sudo rfkill unblock wlan 查询网卡支持的频段 sudo iw reg set AU sudo iw phy phy0 channels 编辑/etc/hostapd/hostapd.conf对 hostapd 进行设置 # 接口与频率设定 # 绑定接口 interface=wlan0 # 802.11a hw_mode=a # 信道 channel=36 # 国家代码 country_code=AU # IEEE802.11d ieee80211d=1 # IEEE802.11h ieee80211h=1 # MAC地址过滤模式 macaddr_acl=0 # 最大连接数 max_num_sta=255 # 隐藏SSID ignore_broadcast_ssid=0 # 启用WMM wmm_enabled=1 # 802.11n/ac (HT/VHT) Settings # IEEE802.11n ieee80211n=1 # IEEE802.11ac ieee80211ac=1 ht_capab=[HT40-][HT40+][SHORT-GI-20][SHORT-GI-40][DSSS_CCK-40][MAX-AMSDU-3839] vht_capab=[MAX-MPDU-3895][SHORT-GI-80][SU-BEAMFORMER][SU-BEAMFORMEE] vht_oper_chwidth=1 vht_oper_centr_freq_seg0_idx=42 #vht_oper_centr_freq_seg1_idx=159 # SSID及安全设置 ssid=RaspAP wpa=2 auth_algs=1 rsn_pairwise=CCMP wpa_key_mgmt=WPA-PSK wpa_passphrase=22223333 注意 在我使用的过程中，ACS(自动选择信道)即channel=0会导致无法启动。 目前已知能正常启动且国外论坛建议的channel / vht_oper_centr_freq_seg0_idx的参数分别为36/42和149/155，即36或149信道。 先测试能否启动 sudo /usr/sbin/hostapd -P /run/hostapd.pid -dd /etc/hostapd/hostapd.conf 如果hostapd正常启动则可通过cltl^C关闭，并使用下列指令设置开机自启并在后台运行。 sudo systemctl unmask hostapd sudo systemctl enable --now hostapd sudo systemctl status hostapd 手机的 WLAN 列表中会显示你的 WiFi 名称，但请不要尝试连接，现在并没有配置 DHCP 服务，你的设备会因为无法分配到 IP 导致无法连接 ","date":"2021-03-03","objectID":"/posts/542347b3/:6:0","tags":["RaspberryPi","iptables","hostapd","dnsmasq"],"title":"把树莓派当作热点","uri":"/posts/542347b3/"},{"categories":["学习日记"],"content":"配置并启用 dnsmasq 备份dnsmasq安装时生成的配置，以便于日后查阅 sudo mv /etc/dnsmasq.conf /etc/dnsmasq.conf.bak 创建/etc/dnsmasq.conf并编辑新配置 interface=wlan0 dhcp-range=172.24.0.2,172.24.0.254,255.255.255.0,2h domain=wlan server=223.5.5.5 address=/raspberry.lan/172.24.0.1 设置开机自启并立即启动dnsmasq sudo systemctl enable --now dnsmasq sudo systemctl restart dnsmasq sudo systemctl status dnsmasq ","date":"2021-03-03","objectID":"/posts/542347b3/:7:0","tags":["RaspberryPi","iptables","hostapd","dnsmasq"],"title":"把树莓派当作热点","uri":"/posts/542347b3/"},{"categories":["学习日记"],"content":"配置 iptables 配置 iptables 实现 NAT 功能，将发送到树莓派的流量截获并修改源地址实现 SNAT sudo iptables -t nat -A POSTROUTING -j MASQUERADE 配置 iptables 永久化，使每次重启后 iptables 都能自动添加之前的规则 sudo netfilter-persistent save ","date":"2021-03-03","objectID":"/posts/542347b3/:8:0","tags":["RaspberryPi","iptables","hostapd","dnsmasq"],"title":"把树莓派当作热点","uri":"/posts/542347b3/"},{"categories":["学习日记"],"content":"树莓派 4 无头启动(Headless)入门指南 注意 以下部分内容仅适用于 Debian 10 (buster) 系统，最新的指南请前往 官网(英文) 查阅。 ","date":"2021-03-03","objectID":"/posts/04c00a0d/:0:0","tags":["RaspberryPi"],"title":"树莓派4入门指南(无显示器)","uri":"/posts/04c00a0d/"},{"categories":["学习日记"],"content":"准备 所需材料: 树莓派*1 SD 卡*1 树莓派系统镜像*1 PC*1 Etcher*1 活人*1 ","date":"2021-03-03","objectID":"/posts/04c00a0d/:1:0","tags":["RaspberryPi"],"title":"树莓派4入门指南(无显示器)","uri":"/posts/04c00a0d/"},{"categories":["学习日记"],"content":"制作带有系统的 SD 卡 从 官网 或者 TUNA 下载 Raspberry Pi OS 的镜像(raspios_lite_arm64)。 打开 Etcher，点击最左侧的Flash from file，选择你所下载的树莓派镜像，点击中间的Select target，勾选你的 SD 卡，点击Select，点击最右边的Flash等待烧录完即可。 烧录完之后系统里面会多出一个命名为boot的分区，在此分区里面创建一个空白的名为ssh的文件以开启 ssh 远程访问。 连接到WiFi网络 在boot分区创建wpa_supplicant.conf并编辑 ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev update_config=1 country=\u003c填写ISO 3166-1国家码\u003e(建议使用`US`,`CN`可能会导致连接不上WiFi) network={ ssid=\"\u003c无线名称\u003e\" psk=\"\u003c无线密码\u003e\" } 使用USB启动 一、更新eeprom 准备一张 SD 卡，格式化成 FAT32 格式 前往Github下载rpi-boot-eeprom-recovery-xxx.zip(要求 vl805 以上的版本) 将 zip 内的文件解压到 SD 卡内 将 SD 卡插入树莓派，插电 等待一段时间，当绿灯开始规律闪烁时则表示更新完毕 二、制作 USB 启动镜像 与制作 SD 卡镜像一样，把勾选 SD 卡改为勾选 USB 设备即可 ","date":"2021-03-03","objectID":"/posts/04c00a0d/:2:0","tags":["RaspberryPi"],"title":"树莓派4入门指南(无显示器)","uri":"/posts/04c00a0d/"},{"categories":["学习日记"],"content":"装配你的树莓派 插上 SD 卡(U 盘)，装上散热马甲(如果有的话)，插上网线，插上电源，静待开机 ","date":"2021-03-03","objectID":"/posts/04c00a0d/:3:0","tags":["RaspberryPi"],"title":"树莓派4入门指南(无显示器)","uri":"/posts/04c00a0d/"},{"categories":["学习日记"],"content":"连接你的树莓派 前往你的路由器查看你的树莓派 IP，一般主机名就是raspberrypi，我的树莓派分配到的 IP 是10.0.0.181，用 ssh 连接(默认用户名:pi密码:raspberry) ssh pi@10.0.0.181 # 进去之后改一下密码 passwd # 第一个输入当前密码，第二个和第三个是新密码 ","date":"2021-03-03","objectID":"/posts/04c00a0d/:4:0","tags":["RaspberryPi"],"title":"树莓派4入门指南(无显示器)","uri":"/posts/04c00a0d/"},{"categories":["学习日记"],"content":"设置镜像并更新 注意 下面的配置用的是 testing 更新通道，软件比较新但也可能出现 BUG 若想使用稳定版请将下面的testing全部替换成buster 设置 Debian 仓库镜像 echo \\ \"# /etc/apt/sources.list deb https://mirrors.sjtug.sjtu.edu.cn/debian testing main contrib non-free deb https://mirrors.sjtug.sjtu.edu.cn/debian testing-updates main contrib non-free deb https://mirrors.sjtug.sjtu.edu.cn/debian-security/ stable/updates main contrib non-free deb-src https://mirrors.sjtug.sjtu.edu.cn/debian testing main contrib non-free deb-src https://mirrors.sjtug.sjtu.edu.cn/debian testing-updates main contrib non-free deb-src https://mirrors.sjtug.sjtu.edu.cn/debian-security/ stable/updates main contrib non-free\" | \\ sudo tee /etc/apt/sources.list \u003e /dev/null 设置 RaspberryPi 仓库镜像 echo \\ \"# /etc/apt/sources.list.d/raspi.list deb https://mirrors.sjtug.sjtu.edu.cn/raspberrypi/debian/ buster main deb-src https://mirrors.sjtug.sjtu.edu.cn/raspberrypi/debian/ buster main\" | \\ sudo tee /etc/apt/sources.list.d/raspi.list \u003e /dev/null 对系统镜像全量更新 sudo apt update sudo apt full-upgrade -y ","date":"2021-03-03","objectID":"/posts/04c00a0d/:5:0","tags":["RaspberryPi"],"title":"树莓派4入门指南(无显示器)","uri":"/posts/04c00a0d/"},{"categories":["学习日记"],"content":"设置中文 注意 如果你的树莓派连接了显示器且没有安装图形界面请不要设置中文，否则会导致乱码 echo \\ 'LANG=zh_CN.UTF-8 LANGUAGE=\"zh_CN:zh:en_US:en\"' | \\ sudo tee /etc/environment \u003e /dev/null 然后重启 然后，Enjoy youself! ","date":"2021-03-03","objectID":"/posts/04c00a0d/:6:0","tags":["RaspberryPi"],"title":"树莓派4入门指南(无显示器)","uri":"/posts/04c00a0d/"},{"categories":["学习日记"],"content":"更多设置 更多的设置(比如 GPIO 等)可以使用树莓派官方的工具进行配置 sudo raspi-config 小技巧 磁盘测速 dd if=/dev/zero of=./test.dbf bs=512k count=1024 conv=fdatasync 将会在当前目录写入一个 512MiB 的test.dbf文件来测试写入速度 查看温度 # 方法一：直接查看系统文件 cat /sys/class/thermal/thermal_zone0/temp # 方法二：通过vcgencmd查看 vcgencmd measure_temp ","date":"2021-03-03","objectID":"/posts/04c00a0d/:7:0","tags":["RaspberryPi"],"title":"树莓派4入门指南(无显示器)","uri":"/posts/04c00a0d/"},{"categories":["杂谈"],"content":"Linux 因为其稳定和安全被不少服务器所使用，我也因为偶然接触到了 Linux，发现了它的方便，甚至将它作为日常系统使用。 ","date":"2021-01-25","objectID":"/posts/2109a7df/:0:0","tags":["Linux"],"title":"Linux ane Me","uri":"/posts/2109a7df/"},{"categories":["杂谈"],"content":"第一次接触 Linux 我一个接触到的 Linux 叫Slax，我也不清楚它算不算一个发行版本，总之它是基于 Debian 的。 当时我高一，上的是封闭式学校，不给带电子产品，一周下来唯一能接触电子产品的时候便是微机课。因为平时的高强度学习，微机课一般都被我们当作放松时间(虽然要过会考)，便想着通过机房的电脑玩些什么。然而学校的老师们早就想到了这一点，通过路由切断了网络，安装了极域电子教室对 USB 进行管控(虽然后期通过注册表找到了卸载密码)。我曾因为重装家里面电脑的系统在 U 盘写了个老毛桃 PE，于是在微机室的电脑上启动试了一下发现可以启动。但是 PE 在运行时将系统加载到内存上，安装的软件关机之后就没有了。于是我在万恶的百度(当时还不会上谷歌)上面搜索\"口袋系统\"，我便在搜索结果里面看到了 Slax。 当时没管那么多，下载下来解压到 U 盘，执行安装脚本。进入系统之后看到了 KDE 桌面和浏览器，那时候只会上网，不知道怎么装软件。 之后官网更新了 Slax9 桌面环境变了，变成了 Slax 自己开发的桌面，但是因为软件太少我也从官网学会了用apt(debian 系 Linux 的包管理器)指令来安装软件，此时的我还没接触到镜像(mirrors)这一概念，看着十几 KB/s 的速度在那傻傻的等软件下好。 虽然当时没有通过 Slax 接触到 Linux 很深层的东西，但是也接触到了 Linux 的部分指令。 ","date":"2021-01-25","objectID":"/posts/2109a7df/:1:0","tags":["Linux"],"title":"Linux ane Me","uri":"/posts/2109a7df/"},{"categories":["杂谈"],"content":"再次接触 过了些时候，忽然不知道在哪看到了国产 Linux(Deepin) 然后就想去试一下，安装完之后被那华丽的动画惊艳了(那时配置不好，有点卡)，体验了一把，确实不错，但是最后被无线网卡的驱动给劝退了(还是因为当时不懂)。之后又看到了网上 Cyborg Hawk Linux(目前好像停止维护了) 的界面，觉得挺帅又去尝试了一下，发现自己不会用，卸载！ Cyborg Hawk Linux ","date":"2021-01-25","objectID":"/posts/2109a7df/:2:0","tags":["Linux"],"title":"Linux ane Me","uri":"/posts/2109a7df/"},{"categories":["杂谈"],"content":"深入接触 真正的接触 Linux 是我买了个树莓派，其系统 Raspbian 基于 Debian，也是因为树莓派让我接触到了 mirrors(镜像)这一概念，看着 9M/s 的下载速度真舒服，后来尝试这在树莓派上面搭建 Wordpress，出于树莓派的性能有限便抛弃了桌面环境使用指令对系统进行操作，刚开始是用 Xshell 连接到树莓派的，后来因为重装了系统懒得下载了便直接使用了 Windows10 自带的 ssh(发现 ssh 真香)。之后又不满足在内网里面搭建博客又在腾讯云买了个云服务器(用的是 Ubuntu Server)而且还搞了备案(因为服务器续费太贵且用不到便退还了服务器并撤销了备案)，然后又折腾了很长时间的 Nginx 和 HTTPS，最后发现服务器带宽太低了就 1Mbps 访问速度非常慢就没搞了。服务器买了一年放在那也是闲着就尝试着搭建了 Minecraft 服务器、内网穿透等等东西。 Raspbian 到此为止我学会了一些简单的指令，比如删除、复制、移动、新建文件夹、使用 nano 编辑文本等。 其实对 Linux 了解最为深入的还是买了笔记本然后在笔记本上装了个 Linux，刚开始装的是 Ubuntu 装了个 Geany 作为 C 语言学习环境，顺便装了个 JRE 用来玩我的世界。结果发现 Ubuntu 有 BUG，显卡驱动有问题，有时候还管不了机，正好看见这样一篇文章《人生苦短，我选 Manjaro》然后就尝试了一下 Manjaro，说实话真的方便安装驱动直接用mhwd指令就能完成。 Manjaro 目前 Manjaro GNOME 是我日常使用的系统，装了 VSCode 还有一些其他 IDE，众所周知，Linux 没用 QQ，我用的是用 yay 装的 com.qq.tim.spark 虽然托盘独立了看起来有点难受，但是使用起来并没有什么大问题。 ","date":"2021-01-25","objectID":"/posts/2109a7df/:3:0","tags":["Linux"],"title":"Linux ane Me","uri":"/posts/2109a7df/"},{"categories":["学习日记"],"content":"iptables 是 Linux 系统上常用的命令行工具，主要用来配置防火墙。运用 iptables 我们能够实现流量的转发、拦截等操作 ","date":"2021-01-18","objectID":"/posts/16e870f5/:0:0","tags":["iptables","Linux"],"title":"iptables从入门到放弃","uri":"/posts/16e870f5/"},{"categories":["学习日记"],"content":"iptables 是什么 iptables 是运行在用户空间的应用软件，通过控制 Linux 内核 netfilter 模块，来管理网络数据包的处理和转发。在大部分 Linux 发行版中，可以通过手册页或man iptables获取用户手册。 netfilter是什么(摘自Wiki) Netfilter，在 Linux 内核中的一个软件框架，用于管理网络数据包。不仅具有网络地址转换（NAT）的功能，也具备数据包内容修改、以及数据包过滤等防火墙功能。利用运作于用户空间的应用软件，如 iptables、ebtables 和 arptables 等，来控制 Netfilter，系统管理者可以管理通过 Linux 操作系统的各种网络数据包。1990 年代，Netfilter 在 Linux 2.3.15 版时进入 Linux 内核，正式应用于 Linux 2.4 版。 简而言之就是 Netfilter 的上层程序，用户通过 iptables 指定规则，由 Netfilter 来执行，实现流量的拦截、转发等操作。 ","date":"2021-01-18","objectID":"/posts/16e870f5/:1:0","tags":["iptables","Linux"],"title":"iptables从入门到放弃","uri":"/posts/16e870f5/"},{"categories":["学习日记"],"content":"iptables 的链(chain) iptables 中有 5 个链，分别与 netfilter 中的 hook 对应 PREROUTING - 对应NF_IP_PRE_ROUTING,任何进入网络堆栈的流量都会触发此 hook。 INPUT - 对应NF_IP_LOCAL_IN，如果数据包发送到本地系统，则在路由传入数据包之后，将触发此 hook。 FORWARD - 对应NF_IP_FORWARD，如果该数据包转发到另一台主机，则在路由输入数据包之后将触发此 hook。 OUTPUT - 对应NF_IP_LOCAL_OUT，由本地的出栈流量触发。 POSTROUTING - 对应NF_IP_POST_ROUTING，任何传出的流量都将触发此 hook。 数据包走向: 目的地址为本机的传入流量: -\u003e PREROUTING -\u003e INPUT 目的地址为其他主机的传入流量: -\u003e PREROUTING -\u003e FORWARD -\u003e POSTROUTING -\u003e 本机出站流量: OUTPUT -\u003e POSTROUTING -\u003e ","date":"2021-01-18","objectID":"/posts/16e870f5/:2:0","tags":["iptables","Linux"],"title":"iptables从入门到放弃","uri":"/posts/16e870f5/"},{"categories":["学习日记"],"content":"iptables 的表(tables) ","date":"2021-01-18","objectID":"/posts/16e870f5/:3:0","tags":["iptables","Linux"],"title":"iptables从入门到放弃","uri":"/posts/16e870f5/"},{"categories":["学习日记"],"content":"filter 表 filter 表是默认的表，如果不指明表则使用此表。其通常用于过滤数据包。其中的内建链包括： INPUT,OUTPUT,FORWARD ","date":"2021-01-18","objectID":"/posts/16e870f5/:3:1","tags":["iptables","Linux"],"title":"iptables从入门到放弃","uri":"/posts/16e870f5/"},{"categories":["学习日记"],"content":"nat 表 nat 表如其名，用于地址转换操作。其中的内建链包括： PREROUTING,POSTROUTING,OUTPUT ","date":"2021-01-18","objectID":"/posts/16e870f5/:3:2","tags":["iptables","Linux"],"title":"iptables从入门到放弃","uri":"/posts/16e870f5/"},{"categories":["学习日记"],"content":"mangle 表 mangle 表用于处理数据包。其和 nat 表的主要区别在于，nat 表侧重连接而 mangle 表侧重每一个数据包。其中内建链列表如下。 PREROUTING,OUTPUT,FORWARD,INPUT,POSTROUTING ","date":"2021-01-18","objectID":"/posts/16e870f5/:3:3","tags":["iptables","Linux"],"title":"iptables从入门到放弃","uri":"/posts/16e870f5/"},{"categories":["学习日记"],"content":"raw 表 raw 表用于处理异常，有如下两个内建链： PREROUTING,OUTPUT 流量流向 ","date":"2021-01-18","objectID":"/posts/16e870f5/:3:4","tags":["iptables","Linux"],"title":"iptables从入门到放弃","uri":"/posts/16e870f5/"},{"categories":["学习日记"],"content":"iptables 的规则(rules) 根据规则匹配条件来尝试匹配报文，一旦匹配成功，就由规则定义的处理动作做出处理。 ","date":"2021-01-18","objectID":"/posts/16e870f5/:4:0","tags":["iptables","Linux"],"title":"iptables从入门到放弃","uri":"/posts/16e870f5/"},{"categories":["学习日记"],"content":"匹配条件 基本匹配条件：源地址，目标地址，传输层协议 扩展匹配条件：由扩展模块定义 ","date":"2021-01-18","objectID":"/posts/16e870f5/:4:1","tags":["iptables","Linux"],"title":"iptables从入门到放弃","uri":"/posts/16e870f5/"},{"categories":["学习日记"],"content":"处理动作 基本处理动作：ACCEPT、DROP 扩展处理动作：REJECT、RETURN、LOG、REDIRECT ","date":"2021-01-18","objectID":"/posts/16e870f5/:4:2","tags":["iptables","Linux"],"title":"iptables从入门到放弃","uri":"/posts/16e870f5/"},{"categories":["学习日记"],"content":"iptables的链：内置链和自定义链 内置链：对应于hook functions 自定义链接：用于内置链的扩展和补充，可实现更灵活的规则管理机制；自定义链可以设置完之后，添加到内置链中，方便管理 待续… (iptables的命令操作) ","date":"2021-01-18","objectID":"/posts/16e870f5/:4:3","tags":["iptables","Linux"],"title":"iptables从入门到放弃","uri":"/posts/16e870f5/"},{"categories":["学习日记"],"content":"实现思路 假设现在有个三节点的链表,每个节点具有两个指针: prev —— 上一节点地址 next —— 下一节点地址 ","date":"2021-01-09","objectID":"/posts/53e2617f/:1:0","tags":["C++"],"title":"C语言链表实现","uri":"/posts/53e2617f/"},{"categories":["学习日记"],"content":"插入节点 注:虚线表示删除,D为插入的节点 按照这个图的操作应该是: C-\u003eprev = D D-\u003enext = C D-\u003eprev = B B-\u003enext = D 假设此时的链表传入的table是B,插入的node为D,那么C语言代码为: table-\u003enext-\u003eprev = node node-\u003enext = table-\u003enext node-\u003eprev = table table-\u003enext = node ","date":"2021-01-09","objectID":"/posts/53e2617f/:1:1","tags":["C++"],"title":"C语言链表实现","uri":"/posts/53e2617f/"},{"categories":["学习日记"],"content":"删除节点 注:虚线表示删除,B为要删除的节点 按照这个图的操作应该是: A-\u003enext = C C-\u003eprev = A 假设此时的链表传入的table是B,那么C语言代码为: table-\u003eprev-\u003enext = table-\u003enext; table-\u003enext-\u003eprev = table-\u003eprev; free(table) ","date":"2021-01-09","objectID":"/posts/53e2617f/:1:2","tags":["C++"],"title":"C语言链表实现","uri":"/posts/53e2617f/"},{"categories":["学习日记"],"content":"代码实现 #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e typedef struct node { int id; //节点ID struct node *prev; //上节点地址 struct node *next; //下节点地址 } node; node *createNode(int uid); //创建(节点ID) void addNode(node *table, int uid, int newUid); //增(链表,节点UID,新建节点UID)[在UID节点后插入] void delNode(node *table, int uid); //删(链表,节点UID) void printTable(node *table); //打印(链表) int main() { node *table = createNode(0); addNode(table, 0, 1); addNode(table, 1, 2); addNode(table, 2, 3); addNode(table, 3, 4); addNode(table, 4, 5); addNode(table, 5, 6); delNode(table, 1); delNode(table, 2); delNode(table, 5); printTable(table); exit(0); } node *createNode(int uid) { node *newTable = (node *)malloc(sizeof(node)); newTable-\u003eid = uid; newTable-\u003eprev = NULL; newTable-\u003enext = NULL; return newTable; } void addNode(node *table, int uid, int newUid) { while (1) { if (table == NULL) { //未查找到相应节点 printf(\"Node %d not find!\\n\", uid); return; } if (table-\u003eid == newUid) { //节点ID已存在 printf(\"Node %d exist!\\n\", newUid); return; } if (table-\u003eid == uid) { //查找到相应节点 node *newTable = (node *)malloc(sizeof(node)); if (table-\u003enext != NULL) { //如果存在下一节点 //建立当前与下一链表的联系 newTable-\u003enext = table-\u003enext; table-\u003enext-\u003eprev = newTable; } //建立当前与上一链表的联系 table-\u003enext = newTable; newTable-\u003eprev = table; //写入当前链表ID newTable-\u003eid = newUid; return; } table = table-\u003enext; } } void delNode(node *table, int uid) { while (1) { if (table == NULL) { //未查找到相应节点 printf(\"Node %d not find!\\n\", uid); return; } if (table-\u003eid == uid) { //查找到相应节点 if (table-\u003enext != NULL) { //如果存在下一节点 //建立上一节点与下一节点的连接 table-\u003eprev-\u003enext = table-\u003enext; table-\u003enext-\u003eprev = table-\u003eprev; } else { //如果不存在下一节点 //设置上一节点的next为NULL table-\u003eprev-\u003enext = NULL; } //释放当前节点 free(table); return; } table = table-\u003enext; } } void printTable(node *table) { while (table != NULL) { printf(\"Node: %d\\n\", table-\u003eid); table = table-\u003enext; } return; } ","date":"2021-01-09","objectID":"/posts/53e2617f/:2:0","tags":["C++"],"title":"C语言链表实现","uri":"/posts/53e2617f/"},{"categories":["学习日记"],"content":"curl是从服务器传输数据或向服务器传输数据的工具，熟悉其用法后，完全可以取代 Postman 这一类的图形界面工具。 ","date":"2020-11-07","objectID":"/posts/9058bdc8/:0:0","tags":["curl","Linux"],"title":"使用curl测试API","uri":"/posts/9058bdc8/"},{"categories":["学习日记"],"content":"常规用法 模拟浏览器向网站发送请求curl \u003cURL\u003e,比如 curl \"https://www.bilibili.com\" ","date":"2020-11-07","objectID":"/posts/9058bdc8/:1:0","tags":["curl","Linux"],"title":"使用curl测试API","uri":"/posts/9058bdc8/"},{"categories":["学习日记"],"content":"参数解释 ","date":"2020-11-07","objectID":"/posts/9058bdc8/:2:0","tags":["curl","Linux"],"title":"使用curl测试API","uri":"/posts/9058bdc8/"},{"categories":["学习日记"],"content":"-X 指定请求方法 指定 HTTP 请求的方法。RESTful API的四种方法: curl -X GET \"https://example.com\" curl -X POST \"https://example.com\" curl -X PUT \"https://example.com\" curl -X DELETE \"https://example.com\" ","date":"2020-11-07","objectID":"/posts/9058bdc8/:2:1","tags":["curl","Linux"],"title":"使用curl测试API","uri":"/posts/9058bdc8/"},{"categories":["学习日记"],"content":"-A 指定UA 指定UA（User-Agent）。curl 的默认用户代理字符串是（curl/[version]）。 curl -A 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36' https://google.com 也可以通过-H参数直接指定 curl -H 'User-Agent: php/1.0' https://google.com ","date":"2020-11-07","objectID":"/posts/9058bdc8/:2:2","tags":["curl","Linux"],"title":"使用curl测试API","uri":"/posts/9058bdc8/"},{"categories":["学习日记"],"content":"-b 发送Cookies 向服务器发送 Cookies。 curl -b 'foo1=bar;foo2=bar2' https://google.com 或者发送本地文件中的Cookies curl -b cookies.txt https://www.google.com ","date":"2020-11-07","objectID":"/posts/9058bdc8/:2:3","tags":["curl","Linux"],"title":"使用curl测试API","uri":"/posts/9058bdc8/"},{"categories":["学习日记"],"content":"-c 保存Cookies 将服务器设置的 Cookies 写入一个文件。 curl -c cookies.txt https://www.google.com ","date":"2020-11-07","objectID":"/posts/9058bdc8/:2:4","tags":["curl","Linux"],"title":"使用curl测试API","uri":"/posts/9058bdc8/"},{"categories":["学习日记"],"content":"-d 发送POST数据体 用于发送 POST 请求的数据体。 curl -d'login=emma＆password=123' -X POST https://google.com/login #或者使用本地文件 curl -d '@data.txt' https://google.com/login 使用-d参数以后，HTTP 请求会自动加上标头Content-Type : application/x-www-form-urlencoded。并且会自动将请求转为 POST 方法，因此可以省略-X POST。 ","date":"2020-11-07","objectID":"/posts/9058bdc8/:2:5","tags":["curl","Linux"],"title":"使用curl测试API","uri":"/posts/9058bdc8/"},{"categories":["学习日记"],"content":"-e 设置Referer 设置 HTTP 的标头Referer，表示请求的来源。 curl -e 'https://google.com?q=example' https://www.example.com 可以通过-H参数直接添加标头Referer，达到同样效果。 curl -H 'Referer: https://google.com?q=example' https://www.example.com ","date":"2020-11-07","objectID":"/posts/9058bdc8/:2:6","tags":["curl","Linux"],"title":"使用curl测试API","uri":"/posts/9058bdc8/"},{"categories":["学习日记"],"content":"-F 上传文件 向服务器上传二进制文件。 curl -F 'file=@photo.png' https://google.com/profile 指定 MIME 类型。 curl -F 'file=@photo.png;type=image/png' https://google.com/profile ","date":"2020-11-07","objectID":"/posts/9058bdc8/:2:7","tags":["curl","Linux"],"title":"使用curl测试API","uri":"/posts/9058bdc8/"},{"categories":["学习日记"],"content":"-H 指定HTTP标头 添加 HTTP 请求的标头。 curl -H 'Accept-Language: en-US' -H 'Secret-Message: xyzzy' https://google.com ","date":"2020-11-07","objectID":"/posts/9058bdc8/:2:8","tags":["curl","Linux"],"title":"使用curl测试API","uri":"/posts/9058bdc8/"},{"categories":["学习日记"],"content":"-i 打印HTTP标头 打印出服务器回应的 HTTP 标头。收到服务器回应后，先输出服务器回应的标头，然后空一行，再输出网页的源码。 curl -i https://www.example.com ","date":"2020-11-07","objectID":"/posts/9058bdc8/:2:9","tags":["curl","Linux"],"title":"使用curl测试API","uri":"/posts/9058bdc8/"},{"categories":["学习日记"],"content":"-k 跳过SSL检测 跳过 SSL 检测。不会检查服务器的 SSL 证书是否正确。 ","date":"2020-11-07","objectID":"/posts/9058bdc8/:2:10","tags":["curl","Linux"],"title":"使用curl测试API","uri":"/posts/9058bdc8/"},{"categories":["学习日记"],"content":"-L 开启重定向 让 HTTP 请求跟随服务器的重定向。curl 默认不跟随重定向。 ","date":"2020-11-07","objectID":"/posts/9058bdc8/:2:11","tags":["curl","Linux"],"title":"使用curl测试API","uri":"/posts/9058bdc8/"},{"categories":["学习日记"],"content":"-o 保存为文件 将服务器的回应保存成文件，等同于wget命令。 curl -o example.html https://www.example.com ","date":"2020-11-07","objectID":"/posts/9058bdc8/:2:12","tags":["curl","Linux"],"title":"使用curl测试API","uri":"/posts/9058bdc8/"},{"categories":["学习日记"],"content":"-u Basic Auth认证 用来设置服务器认证的用户名和密码。 curl -u 'bob:12345' https://google.com/login #或 curl https://bob:12345@google.com/login ","date":"2020-11-07","objectID":"/posts/9058bdc8/:2:13","tags":["curl","Linux"],"title":"使用curl测试API","uri":"/posts/9058bdc8/"},{"categories":["学习日记"],"content":"-x 设置代理 指定 HTTP 请求的代理。 curl -x socks5://user:passwd@proxy.com:8080 https://www.example.com 如果没有指定代理协议，默认为 HTTP。 curl -x user:passwd@proxy.com:8080 https://www.example.com ","date":"2020-11-07","objectID":"/posts/9058bdc8/:2:14","tags":["curl","Linux"],"title":"使用curl测试API","uri":"/posts/9058bdc8/"},{"categories":["学习日记"],"content":"之前用过Hexo写过博客，用过一个插件叫hexo-abbrlink，可以生成文章唯一永久链接(8位16进制的字符串)，Hugo有个slug参数，可以用C++写个小程序生成一串字符并填入来模拟这个功能。 这个实现方式只是通过生成8个0-15的随机数实现的，有概率会出现生成的字符重复的现象(只不过概率特别低)，不过其他方法我也不会啊，只能想到这种实现方式了(我太菜了)，就当作是练习C++的面向对象编程吧。 ","date":"2020-11-05","objectID":"/posts/16ea70f5/:0:0","tags":["C++"],"title":"C++实现生成abbrlink","uri":"/posts/16ea70f5/"},{"categories":["学习日记"],"content":"源代码 引入头文件 #include \u003ciostream\u003e#include \u003ccstdlib\u003e#include \u003cctime\u003eusing namespace std; 声明对象 class Abbrlink { private: int abbr[8]; public: void New() { int seed = (int)time(0); for (int i = 0; i \u003c 8; i++) { int bytes = -1; while ((bytes \u003c 0) || (bytes \u003e 15)) { seed--; srand(seed); bytes = rand() % 16; } abbr[i] = bytes; } } void Print() { for (int i = 0; i \u003c 8; i++) { cout \u003c\u003c hex \u003c\u003c abbr[i]; } cout \u003c\u003c endl; } }; 主函数 int main() { Abbrlink abbr; abbr.New(); abbr.Print(); return 0; } ","date":"2020-11-05","objectID":"/posts/16ea70f5/:1:0","tags":["C++"],"title":"C++实现生成abbrlink","uri":"/posts/16ea70f5/"},{"categories":["学习日记"],"content":"Windows下安装用于编译的MinGW 注: 经不起折腾的人还是老老实实用Dev-C++吧，一键安装，现成的UI！ ","date":"2020-06-12","objectID":"/posts/f1d8b9f4/:0:0","tags":["C/C++","开发环境"],"title":"Windows 下 MinGW 的选择与安装","uri":"/posts/f1d8b9f4/"},{"categories":["学习日记"],"content":"关于MinGW ","date":"2020-06-12","objectID":"/posts/f1d8b9f4/:1:0","tags":["C/C++","开发环境"],"title":"Windows 下 MinGW 的选择与安装","uri":"/posts/f1d8b9f4/"},{"categories":["学习日记"],"content":"MinGW是什么 MinGW（Minimalist GNU for Windows），又称mingw32，是将GCC编译器和GNU Binutils移植到Win32平台下的产物，包括一系列头文件（Win32API）、库和可执行文件。 另有可用于产生32位及64位Windows可执行文件的MinGW-w64项目，是从原本MinGW产生的分支。如今已经独立发展。 ","date":"2020-06-12","objectID":"/posts/f1d8b9f4/:1:1","tags":["C/C++","开发环境"],"title":"Windows 下 MinGW 的选择与安装","uri":"/posts/f1d8b9f4/"},{"categories":["学习日记"],"content":"MinGW的作用 GCC支持的语言大多在MinGW也受支持，其中涵盖C、C++、Objective-C、Fortran及Ada。 对于C语言之外的语言，MinGW使用标准的GNU运行库，如C++使用GNU libstdc++。 但是MinGW使用Windows中的C运行库。因此用MinGW开发的程序不需要额外的第三方DLL支持就可以直接在Windows下运行，而且也不一定必须遵从GPL许可证。这同时造成了MinGW开发的程序只能使用Win32API和跨平台的第三方库，而缺少POSIX支持，大多数GNU软件无法在不修改源代码的情况下用MinGW编译。 ","date":"2020-06-12","objectID":"/posts/f1d8b9f4/:1:2","tags":["C/C++","开发环境"],"title":"Windows 下 MinGW 的选择与安装","uri":"/posts/f1d8b9f4/"},{"categories":["学习日记"],"content":"安装MinGW 如果你已经阅读完上面的内容，并且已经准备好安装MinGW了，那就请阅读下面的内容吧！ 我们先不急着下载，我们先搞懂几个概念，当然，你想边看边下载也可以，下载链接 ","date":"2020-06-12","objectID":"/posts/f1d8b9f4/:2:0","tags":["C/C++","开发环境"],"title":"Windows 下 MinGW 的选择与安装","uri":"/posts/f1d8b9f4/"},{"categories":["学习日记"],"content":"系统架构的选择 这取决于你的电脑，Windows7用户请打开系统属性，Windows10在设置-\u003e系统-\u003e关于-\u003e系统信息，请看到系统类型这一行，这里会告诉你你的系统是64位还是32位，如果是64位请选择x86_64，32位请选择i686 ","date":"2020-06-12","objectID":"/posts/f1d8b9f4/:2:1","tags":["C/C++","开发环境"],"title":"Windows 下 MinGW 的选择与安装","uri":"/posts/f1d8b9f4/"},{"categories":["学习日记"],"content":"系统接口协议的选择 这里我查了好久，垃圾百度上面的东西太杂乱了，根本看不出什么名堂出来，最终还是去查Wiki了，链接：POSIX Win32 (可能需要代理) 共有两种选择，posix和win32。 POSIX(可移植操作系统接口,Portable Operating System Interface)是IEEE为要在各种UNIX操作系统(Linux、MacOS)上运行软件，而定义API的一系列互相关联的标准的总称。微软的Windows NT声称部分实现了POSIX标准。 Windows操作系统应用程序接口（Windows API），有非正式的简称法为WinAPI，是微软对于Windows操作系统中可用的核心应用程序编程接口的称法。它被设计为各种语言的程序调用，也是应用软件与Windows系统最直接的交互方式。大多数驱动程序需要对Windows系统更底层次访问接口，由所用版本的Windows的Native API来提供接口。 总的来说就是，Win32是Windows原生API，POSIX是UNIX的API，Windows仅部分支持，但是好像最大的区别在于线程上面，posix支持C11的多线程功能，支持std::thread，而win32不支持，调用的是Windows的API，这影响你以后写代码时多线程的实现方法，这个你自己选择吧，你偏向于原生的C标准就选posix，面向Windows编程就选win32，如果你还是选择困难的话，毕竟我们最常用的还是Windows，选win32也没什么问题 ","date":"2020-06-12","objectID":"/posts/f1d8b9f4/:2:2","tags":["C/C++","开发环境"],"title":"Windows 下 MinGW 的选择与安装","uri":"/posts/f1d8b9f4/"},{"categories":["学习日记"],"content":"异常处理模型的选择 异常处理模型共三种，seh、dwarf和sjlj，我列一个表你自己选吧. 64位 32位 性能 seh dwarf 稳定 sjlj sjlj 如果你想深入了解，下面是引自Wiki的话 MinGW编译器在实现异常机制时，有三种可选方式： SJLJ (setjmp/longjmp)：可用于32/64位，但不是零代价的：即使不抛出异常，仍会有一定的性能损失（在最差情形下~15%）。 DWARF (DW2, dwarf-2)：只能用于32位，没有永久的运行时开销，需要调用栈是dwarf-enabled，这意味着异常对于Windows system DLLs或Visual Studio编译的DLLs的异常不能被抛出。 SEH：零花销。 ","date":"2020-06-12","objectID":"/posts/f1d8b9f4/:2:3","tags":["C/C++","开发环境"],"title":"Windows 下 MinGW 的选择与安装","uri":"/posts/f1d8b9f4/"},{"categories":["学习日记"],"content":"下载MinGW 下载链接 至于版本，选最新的吧，支持的标准也新一点 下载的时候不要看见大大的绿色按钮就点，往下面翻一下，你会看到这个链接 MinGW-W64-install.exe 但是，不要点他，这是在线安装程序，安装时下载的速度能让你绝望，继续往下翻，看到这些链接，在这里面选 x86_64-posix-sjlj x86_64-posix-seh x86_64-win32-sjlj x86_64-win32-seh i686-posix-sjlj i686-posix-dwarf i686-win32-sjlj i686-win32-dwarf 下载可能会有点慢，那就试试其他下载工具，某雷，或者其他多线程下载器。 ","date":"2020-06-12","objectID":"/posts/f1d8b9f4/:2:4","tags":["C/C++","开发环境"],"title":"Windows 下 MinGW 的选择与安装","uri":"/posts/f1d8b9f4/"},{"categories":["学习日记"],"content":"解压MinGW 下载完之后你会得到一个7z压缩包，下面的软件都可以解压，自己选一个吧(我也不知道哪个好用，我用的是7-zip) 7-Zip和p7zip IZArc PowerArchiver QuickZip Squeez TUGZip WinRAR ZipGenius EZ 7z Bandizip 解压过后得到一个文件夹，重命名一下，为mingw-w64，然后确保这个目录下面有bin文件夹，然后将mingw-w64移动到你想要存放的位置，比如我就放在了D盘，路径为D:\\buildtool\\mingw-w64 ","date":"2020-06-12","objectID":"/posts/f1d8b9f4/:2:5","tags":["C/C++","开发环境"],"title":"Windows 下 MinGW 的选择与安装","uri":"/posts/f1d8b9f4/"},{"categories":["学习日记"],"content":"设置环境变量 解压过后是不能直接用的，我们要把他添加到环境变量里面去，打开设置-\u003e系统-\u003e关于-\u003e系统信息-\u003e高级系统设置-\u003e环境变量，你会注意到有上下两个框。上面的是用户变量，只在自己的用户内有效，更改之后注销重新登录就能生效。下面的是系统变量，全局有效，更改之后需要重启才能生效，当然也有其他方法能让他立即生效。方法是，在改完之后保存，然后打开一个命令行窗口，输入set Path=C:，像更新什么变量就把Path换成那个变量名，然后关闭命令行窗口即可。 然后我们添加mingw-w64到系统变量 建议按照下面这张表添加变量(多个值之间用;分隔) 变量名 变量值 备注 MINGW_HOME D:\\buildtool\\mingw-w64\\ 根据自己的存放位置填写 Path %MINGW_HOME%\\bin\\ 追加，而不是覆盖，注意;分隔 C_INCLUDE_PATH %MINGW_HOME%\\include\\;%MINGW_HOME%\\lib\\gcc\\x86_64-w64-mingw32\\8.1.0\\include\\ 第二个值gcc后面的版本号需自己更改一下 CPLUS_INCLUDE_PATH C++的Include目录 LIBRARY_PATH %MINGW_HOME%\\lib\\ ","date":"2020-06-12","objectID":"/posts/f1d8b9f4/:2:6","tags":["C/C++","开发环境"],"title":"Windows 下 MinGW 的选择与安装","uri":"/posts/f1d8b9f4/"},{"categories":["学习日记"],"content":"验证安装是否成功 改完变量之后最好重启一下 打开命令行，输入gcc -v如果最后一行显示下列字符则表示安装成功，版本可能不一样。 gcc version 8.1.0 (x86_64-win32-seh-rev0, Built by MinGW-W64 project) ","date":"2020-06-12","objectID":"/posts/f1d8b9f4/:2:7","tags":["C/C++","开发环境"],"title":"Windows 下 MinGW 的选择与安装","uri":"/posts/f1d8b9f4/"},{"categories":["Game"],"content":"现在网络上的我的世界服务端有许多，那么他们都有些什么特点呢 ","date":"2020-06-06","objectID":"/posts/d9828d29/:0:0","tags":["Minecraft","Server"],"title":"Minecraft 服务端种类","uri":"/posts/d9828d29/"},{"categories":["Game"],"content":"快速入门 底下那么一大坨认真看的人我觉得不多，直接列举吧 插件服 Bukkit 插件服 SpigotMC PaperMC Sponge 插件服 SpongeVanilla Mod服 Forge Mod服 官方 + Forge Fabric Mod服 官方 + Fabric 混合型 Forge + Sponge (Mod+插件) SpongeForge(本质是Mod，依赖Forge) Forge + Bukkit (Mod+插件) CatServer(存在兼容性问题，仅支持1.12.2) 注:无论是那种服务端，插件放在plugins文件夹，模组放在mods文件夹。上面说过SpongeForge本质是模组，所以SpongeForge.jar不能直接启动，而是放在mods文件夹，sponge插件放在plugins文件夹 ","date":"2020-06-06","objectID":"/posts/d9828d29/:1:0","tags":["Minecraft","Server"],"title":"Minecraft 服务端种类","uri":"/posts/d9828d29/"},{"categories":["Game"],"content":"知识普及 ","date":"2020-06-06","objectID":"/posts/d9828d29/:2:0","tags":["Minecraft","Server"],"title":"Minecraft 服务端种类","uri":"/posts/d9828d29/"},{"categories":["Game"],"content":"API是啥 API（Application Programming Interface，应用程序接口）是一些预先定义的函数，或指软件系统不同组成部分衔接的约定。用来提供应用程序与开发人员基于某软件或硬件得以访问的一组例程，而又无需访问原码，或理解内部工作机制的细节。——摘自百度百科 简单来说就是给模组、插件开发者留的一些功能实现接口。 ","date":"2020-06-06","objectID":"/posts/d9828d29/:2:1","tags":["Minecraft","Server"],"title":"Minecraft 服务端种类","uri":"/posts/d9828d29/"},{"categories":["Game"],"content":"Minecraft现在有哪些API 这些API不是官方提供的，而是修改官方的服务端实现的，下面列举一下 ","date":"2020-06-06","objectID":"/posts/d9828d29/:3:0","tags":["Minecraft","Server"],"title":"Minecraft 服务端种类","uri":"/posts/d9828d29/"},{"categories":["Game"],"content":"Forge 玩mod的人都知道，Forge是一个模组(mod)API，可以让我的世界拥有更多的方块和玩法，典型的例子有工业2，当然也有一些辅助型的mod，比如旅行地图 ","date":"2020-06-06","objectID":"/posts/d9828d29/:3:1","tags":["Minecraft","Server"],"title":"Minecraft 服务端种类","uri":"/posts/d9828d29/"},{"categories":["Game"],"content":"Fabric 与Forge类似，Fabric也是个模组API,与Forge不同的是Fabric是模块化的，主要针对高版本的MC(1.14+)，对Bukkit，Optifine支持友好，加速火把和WorldEdit也都出现了Fabric版本的模组了 ","date":"2020-06-06","objectID":"/posts/d9828d29/:3:2","tags":["Minecraft","Server"],"title":"Minecraft 服务端种类","uri":"/posts/d9828d29/"},{"categories":["Game"],"content":"Bukkit(水桶) Bukkit是一个服务器插件API，大部分插件都是基于这个API的，比如 基础插件(EssX) 登录插件(Authme) 等等，特点是客户端不需要安装，只要服务端安装就行了。典型代表是CraftBukkit，但是被Mojang咬了一口，现在已经Over了。但是不用担心，大部分API已经被Spigot继承了。 ","date":"2020-06-06","objectID":"/posts/d9828d29/:3:3","tags":["Minecraft","Server"],"title":"Minecraft 服务端种类","uri":"/posts/d9828d29/"},{"categories":["Game"],"content":"Sponge(海绵) 这也是一个插件API，他可以建立在原版上，也可以建立在Forge的API之上，使mod和插件同时存在变为可能，也可以单独存在。 ","date":"2020-06-06","objectID":"/posts/d9828d29/:3:4","tags":["Minecraft","Server"],"title":"Minecraft 服务端种类","uri":"/posts/d9828d29/"},{"categories":["Game"],"content":"API总结 API名称 用途 要求 备注 Forge 模组 客户端和服务器均要安装 加载慢占内存,主流 Fabric 模组 客户端和服务器均要安装 新API，支持的模组没Forge多 Bukkit 插件 仅服务端需要安装 老牌API，插件多，主流 Sponge 插件 仅服务端需要安装 插件没Bukkit多 ","date":"2020-06-06","objectID":"/posts/d9828d29/:3:5","tags":["Minecraft","Server"],"title":"Minecraft 服务端种类","uri":"/posts/d9828d29/"},{"categories":["Game"],"content":"服务端介绍 ","date":"2020-06-06","objectID":"/posts/d9828d29/:4:0","tags":["Minecraft","Server"],"title":"Minecraft 服务端种类","uri":"/posts/d9828d29/"},{"categories":["Game"],"content":"官方服务端 官方提供的服务端，在正版启动器和官网能够下载到，不提供任何API，只提供原版的联机能力 ","date":"2020-06-06","objectID":"/posts/d9828d29/:4:1","tags":["Minecraft","Server"],"title":"Minecraft 服务端种类","uri":"/posts/d9828d29/"},{"categories":["Game"],"content":"SpigotMC 是CraftBukkit的改进版本，提供Bukkit API，作为插件服使用，对性能要求稍微低一点，当然插件多了也吃性能。前面也说了CraftBukkit被咬了一口，Spigot为了避免这种情况所以不提供直接下载，只提供Buildtool下载，用户可以通过此工具自己编译服务端。下面给出一个示例代码： java -jar buildtool.jar --rev 1.15.2 注:需要代理 ","date":"2020-06-06","objectID":"/posts/d9828d29/:4:2","tags":["Minecraft","Server"],"title":"Minecraft 服务端种类","uri":"/posts/d9828d29/"},{"categories":["Game"],"content":"PaperMC 是SpigotMC的一个改进版本，也提供Bukkit API，插件服，对于性能要求稍高一些 ","date":"2020-06-06","objectID":"/posts/d9828d29/:4:3","tags":["Minecraft","Server"],"title":"Minecraft 服务端种类","uri":"/posts/d9828d29/"},{"categories":["Game"],"content":"SpongeVanilla 在原版的基础上提供Sponge API，插件服 ","date":"2020-06-06","objectID":"/posts/d9828d29/:4:4","tags":["Minecraft","Server"],"title":"Minecraft 服务端种类","uri":"/posts/d9828d29/"},{"categories":["Game"],"content":"官方+FML(Forge Mod Loader) 在官方的基础上加上Forge API的支持，可以加mod ","date":"2020-06-06","objectID":"/posts/d9828d29/:4:5","tags":["Minecraft","Server"],"title":"Minecraft 服务端种类","uri":"/posts/d9828d29/"},{"categories":["Game"],"content":"官方+Fabric 在官方的基础上加上Fabric API的支持，可以加mod ","date":"2020-06-06","objectID":"/posts/d9828d29/:4:6","tags":["Minecraft","Server"],"title":"Minecraft 服务端种类","uri":"/posts/d9828d29/"},{"categories":["Game"],"content":"官方+Forge+SpongeForge SpongeForge本质上可以算是一个Mod，在Forge API上面提供Spong API支持，同时支持模组和插件 ","date":"2020-06-06","objectID":"/posts/d9828d29/:4:7","tags":["Minecraft","Server"],"title":"Minecraft 服务端种类","uri":"/posts/d9828d29/"},{"categories":["Game"],"content":"CatServer 一个魔改版本，同时支持Forge API和Bukkit API，只支持1.12.2，存在兼容性问题，有时会导致Mod功能失效，例如AE2(应用能源)的空间塔 ","date":"2020-06-06","objectID":"/posts/d9828d29/:4:8","tags":["Minecraft","Server"],"title":"Minecraft 服务端种类","uri":"/posts/d9828d29/"},{"categories":["Game"],"content":"服务端总结 服务端名称 用途 要求 备注 支持版本 官方 原版联机 无 All SpigotMC 插件服 无 1.8+ PaperMC 插件服 无 1.8+ SpongeVanilla 插件服 无 支持插件较少，没Bukkit全 1.8+ 官方+FML 模组服 客户端需安装Forge及对应模组 ALL 官方+Fabric 模组服 客户端需安装Fabric及对应模组 支持模组较少 1.14+ CatServer 模组+插件服 客户端需安装Forge及对应模组 存在不兼容问题 1.12.2 另类: SpongeForge 模组+插件服 客户端需安装Forge及对应模组 本质是一个模组，需基于Forge，支持插件较少 1.8+ ","date":"2020-06-06","objectID":"/posts/d9828d29/:4:9","tags":["Minecraft","Server"],"title":"Minecraft 服务端种类","uri":"/posts/d9828d29/"},{"categories":["学习日记"],"content":"在右键菜单里面添加你想要的内容，让你的操作更加流畅方便，也可以删除一些失效的快捷方式 ","date":"2020-06-05","objectID":"/posts/b7b8efff/:0:0","tags":["Windows"],"title":"添加Windows右键菜单选项","uri":"/posts/b7b8efff/"},{"categories":["学习日记"],"content":"直接将选项添加至右键菜单 先打开注册表编辑器(win+R键，输入regedit，确定) 定位到下表里面的位置 路径 作用 HKEY_CLASSES_ROOT\\*\\shell\\ 任意文件上的右键菜单 HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\ 文件夹空白处的右键菜单 HKEY_CLASSES_ROOT\\Directory\\shell\\ 文件夹上的右键菜单 创建一个项，名称随意，尽量为英文且自己能看懂，修改该项的默认值，默认值即为显示名称,如需图标则创建字串符值Icon，值为图标的绝对路径，然后在刚刚创建的项里面再创建一个项名称一定为command，该项的默认值即为指令。 上面的一段话可能有点绕，下面来个例子(创建在此处打开CMD)： 路径 类型 值 作用 HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\OpenCMD\\(默认) REG_SZ 在此处打开CMD 显示名称 HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\OpenCMD\\Icon REG_SZ cmd.exe 显示图标 HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\OpenCMD\\command\\(默认) REG_SZ cmd.exe 操作\u0026指令 ","date":"2020-06-05","objectID":"/posts/b7b8efff/:1:0","tags":["Windows"],"title":"添加Windows右键菜单选项","uri":"/posts/b7b8efff/"},{"categories":["学习日记"],"content":"创建二级菜单 ","date":"2020-06-05","objectID":"/posts/b7b8efff/:2:0","tags":["Windows"],"title":"添加Windows右键菜单选项","uri":"/posts/b7b8efff/"},{"categories":["学习日记"],"content":"将指令注册进系统 将注册表定位到HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\，在里面创建项例子如下(例子:在此处打开CMD)(表中路径有省略)： 路径 类型 值 作用 HKEY_LOCAL_MACHINE\\...\\CommandStore\\shell\\opencmd\\(默认) REG_SZ 空 无作用 HKEY_LOCAL_MACHINE\\...\\CommandStore\\shell\\opencmd\\icon REG_SZ cmd.exe 显示图标 HKEY_LOCAL_MACHINE\\...\\CommandStore\\shell\\opencmd\\MUIVerb REG_SZ 在此处打开CMD 显示名称 HKEY_LOCAL_MACHINE\\...\\CommandStore\\shell\\opencmd\\command\\(默认) REG_SZ cmd.exe 操作\u0026指令 ","date":"2020-06-05","objectID":"/posts/b7b8efff/:2:1","tags":["Windows"],"title":"添加Windows右键菜单选项","uri":"/posts/b7b8efff/"},{"categories":["学习日记"],"content":"在想要的地方创建菜单项 定位到下表位置(对，就是第一节的那张表) 路径 作用 HKEY_CLASSES_ROOT\\*\\shell\\ 任意文件上的右键菜单 HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\ 文件夹空白处的右键菜单 HKEY_CLASSES_ROOT\\Directory\\shell\\ 文件夹上的右键菜单 然后直接上表吧，更直观一点 路径 类型 值 作用 HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\menu1\\(默认) REG_SZ 空 无作用 HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\menu1\\Icon REG_SZ 显示图标 HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\menu1\\MUIVerb REG_SZ 快捷操作 显示名称 HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\menu1\\subcommands REG_SZ opencmd; 菜单项目 注:subcommands里面可以添加多项，用;分隔，比如：command1;command2,如果想对项目进行分隔分类可以使用|,比如command1;|;command2;command3 ","date":"2020-06-05","objectID":"/posts/b7b8efff/:2:2","tags":["Windows"],"title":"添加Windows右键菜单选项","uri":"/posts/b7b8efff/"},{"categories":["学习日记"],"content":"教你从零开始搭建自己的Hexo博客 ","date":"2020-04-16","objectID":"/posts/4b1b8c9f/:0:0","tags":["Hexo","Blog"],"title":"从零开始搭建Hexo博客","uri":"/posts/4b1b8c9f/"},{"categories":["学习日记"],"content":"简介 ","date":"2020-04-16","objectID":"/posts/4b1b8c9f/:1:0","tags":["Hexo","Blog"],"title":"从零开始搭建Hexo博客","uri":"/posts/4b1b8c9f/"},{"categories":["学习日记"],"content":"什么是Hexo Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 ","date":"2020-04-16","objectID":"/posts/4b1b8c9f/:1:1","tags":["Hexo","Blog"],"title":"从零开始搭建Hexo博客","uri":"/posts/4b1b8c9f/"},{"categories":["学习日记"],"content":"安装前提 安装 Hexo 相当简单，只需要先安装下列应用程序即可： Node.js (Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本) Git 如果您的电脑中已经安装上述必备程序，那么恭喜您！你可以直接前往 安装 Hexo 步骤。 ","date":"2020-04-16","objectID":"/posts/4b1b8c9f/:1:2","tags":["Hexo","Blog"],"title":"从零开始搭建Hexo博客","uri":"/posts/4b1b8c9f/"},{"categories":["学习日记"],"content":"安装 ","date":"2020-04-16","objectID":"/posts/4b1b8c9f/:2:0","tags":["Hexo","Blog"],"title":"从零开始搭建Hexo博客","uri":"/posts/4b1b8c9f/"},{"categories":["学习日记"],"content":"安装git Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git官方安装指南 安装完成后可以打开cmd(命令提示符)或PowerShell执行下面的指令检查git是否安装成功 git version 如果返回 git version xxx.xxx 则表示git安装成功 ","date":"2020-04-16","objectID":"/posts/4b1b8c9f/:2:1","tags":["Hexo","Blog"],"title":"从零开始搭建Hexo博客","uri":"/posts/4b1b8c9f/"},{"categories":["学习日记"],"content":"安装Node.JS Node.js® 是一个基于 Chrome V8 引擎 的 JavaScript 运行时。 Node.js 为大多数平台提供了官方的安装程序。对于中国大陆地区用户，可以前往淘宝 Node.js 镜像下载。 官方链接 淘宝镜像 致Windows用户： 使用Nodejs官方安装程序时，请确保勾选Add to PATH选项（默认已勾选）。 安装完成后可以打开cmd(命令提示符)或PowerShell执行下面的指令检查Node.JS是否安装成功 node -v 如果返回 vXX.XX.X # 例如 v12.16.2 则表示Node.JS安装成功 ","date":"2020-04-16","objectID":"/posts/4b1b8c9f/:2:2","tags":["Hexo","Blog"],"title":"从零开始搭建Hexo博客","uri":"/posts/4b1b8c9f/"},{"categories":["学习日记"],"content":"配置Node.JS镜像源(非中国大陆用户请跳过) 打开cmd(命令提示符)或PowerShell执行下面的指令 npm config set registry https://registry.npm.taobao.org/ 再执行 npm get registry 返回以下内容则表示修改成功 https://registry.npm.taobao.org/ ","date":"2020-04-16","objectID":"/posts/4b1b8c9f/:2:3","tags":["Hexo","Blog"],"title":"从零开始搭建Hexo博客","uri":"/posts/4b1b8c9f/"},{"categories":["学习日记"],"content":"进入正题，安装Hexo 打开cmd(命令提示符)或PowerShell执行下面的指令 npm install -g hexo-cli 安装完成后可以输入以下指令查看Hexo是否安装成功 hexo -v ","date":"2020-04-16","objectID":"/posts/4b1b8c9f/:2:4","tags":["Hexo","Blog"],"title":"从零开始搭建Hexo博客","uri":"/posts/4b1b8c9f/"},{"categories":["学习日记"],"content":"使用Hexo建立属于自己的blog ","date":"2020-04-16","objectID":"/posts/4b1b8c9f/:3:0","tags":["Hexo","Blog"],"title":"从零开始搭建Hexo博客","uri":"/posts/4b1b8c9f/"},{"categories":["学习日记"],"content":"初始化一个blog 我们要找一个方便找到的地方来存放我们的Hexo博客，因为只有这样我们才能更方便的编辑，但是我不建议直接放在桌面上，因为对我来说，我不喜欢桌面有太多东西，而且还有可能把它们误删掉 这里我把它放在D:盘来做演示 打开cmd(命令提示符)或PowerShell cd D: hexo init myblog # 这里的myblog是存放博客文件夹名字，你也可以换成你喜欢的名字 因为途中会克隆Github仓库中的某些文件，所以过程会有些漫长，多等一会就好了 如果你看到了绿色的 INFO 和以下信息，说明Hexo初始化成功了 INFO Start blogging with Hexo! 如果你看到了红色的 FATAL 和以下信息，则表示myblog文件夹不是空的，请删除后再重试，或重新找一个文件夹 FATAL D:\\myblog not empty, please run `hexo init` on an empty folder and then copy your files into it FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html ","date":"2020-04-16","objectID":"/posts/4b1b8c9f/:3:1","tags":["Hexo","Blog"],"title":"从零开始搭建Hexo博客","uri":"/posts/4b1b8c9f/"},{"categories":["学习日记"],"content":"进入博客文件夹测试 打开D:\\myblog可以看到以下目录结构 node_modules # 你博客的插件目录 scaffolds # 中文翻译脚手架，是存放生成新页面的模板文件的地方 source # 你写文章的地方，所有文章和图片、文件都应该存放在这里 themes # 主题文件夹，用于存放自定义主题 .gitignore # git生成的文件，不用管 _config.yml # 你的Hexo博客配置 package.json # 你的Hexo的插件列表 package-lock.json # 在`npm install`后生成的，用来记录实际安装的插件版本 我们在myblog文件夹里面打开cmd(命令提示符)或PowerShell，执行 hexo g 如何在某个文件夹里面打开命令行？ 按住Shitf键，在文件夹的空白处右击，选择在此处打开命令提示符或者在此处打开PowerShell即可 经过下面一番输出后，文件夹里面应该多出来了一个public文件夹 INFO Start processing INFO Files loaded in 120 ms # ··· # 此处省略不知道多少字 # ··· INFO 28 files generated in 400 ms public文件夹是用来存放静态网页的，和他的名字一样，里面的网页是用来发布的，我们输入以下指令，即可预览我们的博客长什么样 hexo s # 执行这段代码后我们可以用浏览器打开 # 127.0.0.1:4000 或 localhost:4000 来预览 如果要关闭预览，我们关闭浏览器，然后在刚刚执行hexo s的那个窗口里面按下Ctrl+C即可终止 ","date":"2020-04-16","objectID":"/posts/4b1b8c9f/:3:2","tags":["Hexo","Blog"],"title":"从零开始搭建Hexo博客","uri":"/posts/4b1b8c9f/"},{"categories":["学习日记"],"content":"对博客的标题和信息进行自定义 在阅读本节之前，建议学习YAML语法 传送门 预览过后我们发现，这个博客的标题叫做Hexo，根本不能彰显我们的个性，所以我们要对配置进行更改让他显示我们想要的标题和其他信息 打开_config.yml文件，找到这几行，并做更改 title:Hexo # 博客标题subtitle:''# 博客副标题description:''# 博客描述keywords:# 关键词(用于搜索引擎优化的(SEO)可以不用填)author:John Doe # 作者language:en # 语言,要改成中文的话就把这里的 en 改成 zh-CHtimezone:''# 时区可以不改 改完之后保存，执行以下指令然后打开localhost:4000来预览 hexo clean # 清理旧的静态文件 hexo g # 生成新的静态文件 hexo s # 启动本地服务器进行预览 预览之后，我们就发现，标题已经变成我们想要的样子了 ","date":"2020-04-16","objectID":"/posts/4b1b8c9f/:3:3","tags":["Hexo","Blog"],"title":"从零开始搭建Hexo博客","uri":"/posts/4b1b8c9f/"},{"categories":["学习日记"],"content":"创建新的文章 我们在myblog文件夹里面打开cmd(命令提示符)或PowerShell，执行 hexo new \"我的第一篇文章\" # 这里的\"我的第一篇文章\"可以写你自己的标题 然后我们打开\\source\\_posts\\我的第一篇文章.md文件，进行编辑，编辑完成后保存，执行以下代码就可以了 hexo clean # 清理旧的静态文件 hexo g # 生成新的静态文件 hexo s # 启动本地服务器进行预览 ","date":"2020-04-16","objectID":"/posts/4b1b8c9f/:3:4","tags":["Hexo","Blog"],"title":"从零开始搭建Hexo博客","uri":"/posts/4b1b8c9f/"},{"categories":["学习日记"],"content":"对博客进行发布 使用hexo s预览的页面仅仅只有我们自己能看到，如果想让别人看到的话我们要进行发布，发布Hexo博客有两种方式 使用云主机或网站服务器发布 借助各大源码平台的pages服务发布 ","date":"2020-04-16","objectID":"/posts/4b1b8c9f/:4:0","tags":["Hexo","Blog"],"title":"从零开始搭建Hexo博客","uri":"/posts/4b1b8c9f/"},{"categories":["学习日记"],"content":"使用云主机或网站服务器发布 将public文件夹下的所有文件上传至服务器的网站根目录即可 具体操作请自行百度或者联系你的服务器提供者 ","date":"2020-04-16","objectID":"/posts/4b1b8c9f/:4:1","tags":["Hexo","Blog"],"title":"从零开始搭建Hexo博客","uri":"/posts/4b1b8c9f/"},{"categories":["学习日记"],"content":"借助各大源码平台的pages服务发布 这里列出几个代码托管平台 Github Gitee码云 Coding 怎么注册和怎么使用我就不说了，自行研究和百度，这里只讲Hexo的操作方法 首先我们得先安装一个插件hexo-deployer-git，通过以下指令安装 npm install hexo-deployer-git --save 之后我们在_config.yml里面找到并修改以下内容(没有的话就自行复制进去) deploy:type:git # 仓库类型(svn或git)repository:git@xxx.com:xxx/xxx.git # 仓库地址(推荐使用SSH方式，SSH涉及的公钥创建及配置问题自行百度)branch:master # 上传的分支 配置好之后保存，然后执行 hexo d 第一次连接会让你确认签名，输入yes之后回车就行了 进入你的代码平台的仓库页面，打开pages服务，输入他提供的网址即可访问 恭喜你!创建了一个属于自己的博客! ","date":"2020-04-16","objectID":"/posts/4b1b8c9f/:4:2","tags":["Hexo","Blog"],"title":"从零开始搭建Hexo博客","uri":"/posts/4b1b8c9f/"},{"categories":null,"content":" Arduino入门 计算机引导的进化之路 ","date":"0001-01-01","objectID":"/todo/:0:0","tags":null,"title":"Todo","uri":"/todo/"},{"categories":null,"content":" -- ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"关于网站 首先，欢迎您来到我的博客，至于我为什么会搭建这个博客，我引用一下主题作者的话: 人最重要的特点是会思考，写博客的初衷是保存思维的电子快照。 当然各种文档工具亦或是简单的文本编辑器也能随时记录点滴， 选择建个人网站无非是想满足技术爱好者的偏执。—— Dillon 因为学业繁忙(其实就是懒)，博客可能长年不更新，所以部分内容可能会过时。 ","date":"0001-01-01","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"关于作者 (不告诉你)岁，是学生(手动狗头) 💻 技术宅，想要探索关于计算机的一切 🤪 拖延症患者，导致想学的东西一直没有学完 ","date":"0001-01-01","objectID":"/about/:2:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"版权问题 除特殊说明外，本站所有内容均受CC BY-NC-SA 4.0保护。 许可协议条款摘要 署名 — 您必须给出适当的署名，提供指向本许可协议的链接，同时标明是否（对原始作品）作了修改。您可以用任何合理的方式来署名，但是不得以任何方式暗示许可人为您或您的使用背书。 非商业性使用 — 您不得将本作品用于商业目的。 相同方式共享 — 如果您再混合、转换或者基于本作品进行创作，您必须基于与原先许可协议相同的许可协议 分发您贡献的作品。 没有附加限制 — 您不得适用法律术语或者 技术措施 从而限制其他人做许可协议允许的事情。 ","date":"0001-01-01","objectID":"/about/:3:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":" 人最重要的特点是会思考，写博客的初衷是保存思维的电子快照。 当然各种文档工具亦或是简单的文本编辑器也能随时记录点滴， 选择建个人网站无非是想满足技术爱好者的偏执。—— Dillon 旧社会已经过去了，但是人们却开始给自己的大脑裹上小脚。 ","date":"0001-01-01","objectID":"/quot/:0:0","tags":null,"title":"凡人名言","uri":"/quot/"},{"categories":null,"content":"不用怀疑！这就是个记事本！· Android SDK Platform Tools 下载地址 官网 直接下载最新版本(请自行前往官网阅读用户协议) Windows Linux MacOS Chrome 离线安装包下载地址 标准版 https://www.google.cn/chrome/?standalone=1 测试版 https://www.google.cn/chrome/beta/?standalone=1 https://www.google.cn/intl/zh-CN/chrome/beta/?standalone=1 开发版 https://www.google.cn/chrome/dev/?standalone=1 https://www.google.cn/intl/zh-CN/chrome/dev/?standalone=1 金丝雀版(无离线安装包，但可正常更新) https://www.google.cn/chrome/canary/ Minecraft Metadata https://launchermeta.mojang.com/mc/game/version_manifest.json https://download.mcbbs.net/mc/game/version_manifest.json Git 常用指令 设置用户名及邮箱 git config --global user.name \"username\" git config --global user.email username@demo.com 配置默认文本编辑器与差异对比工具 git config --global core.editor vim git config --global merge.tool vimdiff 包含子模块 clone git clone --recursive $REPO_URL Linux 下使用环境变量使用NVIDIA显卡启动软件 参考文档: https://download.nvidia.com/XFree86/Linux-x86_64/435.21/README/primerenderoffload.html 变量： __NV_PRIME_RENDER_OFFLOAD=1 __GLX_VENDOR_LIBRARY_NAME=nvidia Debian删除或添加系统架构 查看现有架构 sudo dpkg --print-architecture 添加架构 sudo dpkg --add-architecture $ARCH 删除架构 sudo dpkg --remove-architecture $ARCH 其中 $ARCH 填写架构名，如：i386、amd64、arm64 搭建Theia docker run \\ -d \\ --security-opt \\ seccomp=unconfined \\ --init -it \\ -p 2900:3000 \\ --restart=always \\ --name=theia \\ -v \"/home/theia:/home/project:cached\" \\ theiaide/theia-cpp:latest 配置一个自认为高效的终端 安装以下软件 zsh zsh-autosuggestions zsh-syntax-highlighting starship 编辑~/.zshrc source /usr/share/zsh-autosuggestions/zsh-autosuggestions.zsh source /usr/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh HISTSIZE=1000 SAVEHIST=1000 HISTFILE=~/.zsh_history alias grep=\"grep --color=auto\" alias ls=\"ls --color -lh\" eval \"$(starship init zsh)\" 编辑~/.config/starship.toml [character] success_symbol = \"[➜](bold green) \" error_symbol = \"[➜](bold red) \" [hostname] ssh_only = false format = \"[@$hostname](bold red) \" trim_at = \".companyname.com\" disabled = false [username] style_user = \"green bold\" style_root = \"red bold\" format = \"[$user]($style) \" disabled = false show_always = true fastboot在windows下的异常问题 管理员身份运行 reg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\usbflags\\18D1D00D0100\" /v \"osvc\" /t REG_BINARY /d \"0000\" /f reg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\usbflags\\18D1D00D0100\" /v \"SkipContainerIdQuery\" /t REG_BINARY /d \"01000000\" /f reg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\usbflags\\18D1D00D0100\" /v \"SkipBOSDescriptorQuery\" /t REG_BINARY /d \"01000000\" /f 电信光猫超级密码 帐号: telecomadmin 密码: nE7jA%5m SSH本地端口转发 通俗一点: 内网穿透 A \u003c===\u003e B \u003c==|NAT/防火墙|==\u003e C 由 C 发起，将 C 本机或局域网内的端口映射到 B，A 可通过 B 访问到 C ssh -gN -R $ListenIP:$ListenPort:$LocalIP:$LocalPort $RemoteUser@$RemoteIP $ListenIP: B 要监听的 IP $ListenPort: B 要监听的端口 $LocalIP: C 本地的目标 IP $LocalPort C 本地的目标端口 $RemoteUser B 上的用户 $RemoteIP B 的 IP 比如将本机的 Minecraft 服务器映射到 172.16.0.1 (用户名: User) ssh -gN -R 0.0.0.0:25565:127.0.0.1:25565 User@17.16.0.1 注意 B 机上的 ssh 需开启GatewayPorts OpenSSH 配置 /etc/ssh/sshd_config ... #GatewayPorts no GatewayPorts yes ... Dropbear 配置 /etc/config/dropbear config dropbear ... option GatewayPorts 'on' Openwrt 手动安装 fprs Github frps -\u003e /usr/bin/frps frps.ini -\u003e /etc/frps/frps.ini frps.init -\u003e /etc/init.d/frps /etc/frps/frps.ini [common] bind_port = 7000 token = \u003c自己生成\u003e /etc/init.d/frps #!/bin/sh /etc/rc.common START=99 USE_PROCD=1 BINARY=/usr/bin/frps CONF=/etc/frps/frps.ini start_service() { procd_open_instance procd_set_param command $BINARY -c $CONF procd_set_param file $CONF procd_set_param respawn procd_close_instance } ","date":"0001-01-01","objectID":"/note/:1:0","tags":null,"title":"📋随手记","uri":"/note/"}]